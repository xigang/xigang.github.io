<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Kubernetes Client-Go Informer 实现源码剖析 | xigang's home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kubernetes Client-Go Informer 实现源码剖析</h1><a id="logo" href="/.">xigang's home</a><p class="description">Do it right or don't do it at all</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kubernetes Client-Go Informer 实现源码剖析</h1><div class="post-meta">Sep 21, 2019<span> | </span><span class="category"><a href="/categories/kubernetes/">kubernetes</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>client-go package包含了许多的机制来方便开发者去开发自定义的<code>controllers</code>。之前基于该包实现过收集日志控制器log-controller，负载均衡控制器lb-controller以及收集k8s事件并写入相应的sink的eventrouter等，但是在使用的过程中对client-go内部的实现机制细节，一直比较模糊，所以抽时间分析下client-go的内部机制，在这里做下记录。</p>
<a id="more"></a>
<p>这张图描述了client-go包各个组件之间是如何结合工作的一个整体架构:</p>
<div align="left"><br><img src="http://p3.qhimg.com/t01dcd05613a7827aa1.jpg" width="800" height="600" alt="client-go"><br></div>

<p>注意: 这张图分为两部分,黄色图标是开发者需要自行开发的部分，而其它的部分是client-go已经提供的，直接使用即可。</p>
<ol>
<li>通过controller中的Reflector来实现监听，它通过Kubernetes的List/Watch机制将得到的事件(Object)写入到Store(Delta FIFO)中，后续会基于该Delta FIFO实现完全按事件发生的顺序进行分发处理。</li>
<li>由Reflector生产的事件最终由processor消费。processor通过POP队列(Delta FIFO)里的事件，更新本地的informer indexer缓存，同时将事件distribute给所有的listener。</li>
<li>processer的listener由外部通过AddEventHandler注册，每个listener提供AddFunc, UpdateFunc, DeleteFunc方法。listener内部的实现加了一层缓存，用于存放pendingNotification。listener最终实现了事件的分发，事件最终被注册的handler处理。</li>
<li>注册的handler可以根据事件的类型ADD,UPDATE,DELETE，将该事件的key(格式: namespace/resource_name)Enqueue到client-go提供的Workqueue队列中。</li>
<li>开发者需要实现自己的controller syncHandler(就是自己的核心逻辑)，从Workqueue中获取key，并通过这个key解析出namespace和resource_name去调用Lister从indexer中获取该key对应的相应的元数据进行后续的逻辑处理。</li>
</ol>
<p>上面就是开发者想要写一个controller(或者有的人也叫operator)的一个整体的流程。</p>
<h3 id="SharedInformerFactory"><a href="#SharedInformerFactory" class="headerlink" title="SharedInformerFactory"></a>SharedInformerFactory</h3><p>SharedInformerFactory为kubernetes中的所有资源(API group versions)提供了一个shared informer。所以controller中使用的所有Informer都是从SharedInformerFactory中通过GroupVersionResource得到。</p>
<p>SharedInformerFactory的声明结构:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type SharedInformerFactory interface &#123;</span><br><span class="line">	internalinterfaces.SharedInformerFactory</span><br><span class="line">	ForResource(resource schema.GroupVersionResource) (GenericInformer, error)</span><br><span class="line">	WaitForCacheSync(stopCh &lt;-chan struct&#123;&#125;) map[reflect.Type]bool</span><br><span class="line"></span><br><span class="line">	Admissionregistration() admissionregistration.Interface</span><br><span class="line">	Apps() apps.Interface</span><br><span class="line">	Auditregistration() auditregistration.Interface</span><br><span class="line">	Autoscaling() autoscaling.Interface</span><br><span class="line">	Batch() batch.Interface</span><br><span class="line">	Certificates() certificates.Interface</span><br><span class="line">	Coordination() coordination.Interface</span><br><span class="line">	Core() core.Interface</span><br><span class="line">	Events() events.Interface</span><br><span class="line">	Extensions() extensions.Interface</span><br><span class="line">	Networking() networking.Interface</span><br><span class="line">	Policy() policy.Interface</span><br><span class="line">	Rbac() rbac.Interface</span><br><span class="line">	Scheduling() scheduling.Interface</span><br><span class="line">	Settings() settings.Interface</span><br><span class="line">	Storage() storage.Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Events的声明结构:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Interface</span> provides access to all the informers <span class="keyword">in</span> this group version.</span><br><span class="line"><span class="keyword">type</span> <span class="type">Interface</span> interface &#123;</span><br><span class="line">	// <span class="type">Events</span> returns a <span class="type">EventInformer</span>.</span><br><span class="line">	<span class="type">Events</span>() <span class="type">EventInformer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventInformer的声明结构:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">EventInformer</span> provides access to a shared informer and lister for</span><br><span class="line">// <span class="type">Events</span>.</span><br><span class="line"><span class="keyword">type</span> <span class="type">EventInformer</span> interface &#123;</span><br><span class="line">	<span class="type">Informer</span>() cache.<span class="type">SharedIndexInformer</span></span><br><span class="line">	<span class="type">Lister</span>() v1beta1.<span class="type">EventLister</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样如果我们想使用EventInformer,那么我们就直接在SharedInformerFactory中获取我们需要的Informer即可。只需要执行下面的两行代码:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sharedInformers := informers.NewSharedInformerFactory(clientset, viper.GetDuration(<span class="string">"resync-interval"</span>))</span><br><span class="line"></span><br><span class="line">eventsInformer := sharedInformers.Core().V1().Events()</span><br></pre></td></tr></table></figure>
<h3 id="Register-Informer"><a href="#Register-Informer" class="headerlink" title="Register Informer"></a>Register Informer</h3><p>已经获取了我们想要使用的EventInformer，接下来就需要将该Informer注册到factory(SharedInformerFactory),其实在调用<code>eventsInformer.Informer()</code>时，就已经做了Informer注册的工作,之后通过informerFactory.Start()将所有注册到factory的Informer都启动。</p>
<p>下面是注册EventInformer的一个实现逻辑:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func NewFilteredEventInformer(client kubernetes<span class="selector-class">.Interface</span>, namespace string, resyncPeriod <span class="selector-tag">time</span><span class="selector-class">.Duration</span>, indexers cache<span class="selector-class">.Indexers</span>, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache<span class="selector-class">.SharedIndexInformer</span> &#123;</span><br><span class="line">	return cache.NewSharedIndexInformer(</span><br><span class="line">		&amp;cache.ListWatch&#123;</span><br><span class="line">			ListFunc: func(options metav1.ListOptions) (runtime<span class="selector-class">.Object</span>, error) &#123;</span><br><span class="line">				<span class="keyword">if</span> tweakListOptions != nil &#123;</span><br><span class="line">					tweakListOptions(&amp;options)</span><br><span class="line">				&#125;</span><br><span class="line">				return client.CoreV1().Events(namespace).List(options)</span><br><span class="line">			&#125;,</span><br><span class="line">			WatchFunc: func(options metav1.ListOptions) (watch<span class="selector-class">.Interface</span>, error) &#123;</span><br><span class="line">				<span class="keyword">if</span> tweakListOptions != nil &#123;</span><br><span class="line">					tweakListOptions(&amp;options)</span><br><span class="line">				&#125;</span><br><span class="line">				return client.CoreV1().Events(namespace).Watch(options)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&amp;corev1.Event&#123;&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">		indexers,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *eventInformer) defaultInformer(client kubernetes<span class="selector-class">.Interface</span>, resyncPeriod <span class="selector-tag">time</span>.Duration) cache<span class="selector-class">.SharedIndexInformer</span> &#123;</span><br><span class="line">	return NewFilteredEventInformer(client, f<span class="selector-class">.namespace</span>, resyncPeriod, cache.Indexers&#123;cache<span class="selector-class">.NamespaceIndex</span>: cache.MetaNamespaceIndexFunc&#125;, f.tweakListOptions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *eventInformer) Informer() cache<span class="selector-class">.SharedIndexInformer</span> &#123;</span><br><span class="line">	return f<span class="selector-class">.factory</span><span class="selector-class">.InformerFor</span>(&amp;corev1.Event&#123;&#125;, f.defaultInformer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sharedInformerFactory的声明结构, 在这里我们主要关注<code>informers</code>和<code>startedInformers</code>，其中<code>informers</code>主要的是存储，向该factory已经注册的Informer,而<code>startedInformers</code>主要记录哪些Informer已经启动了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type sharedInformerFactory struct &#123;</span><br><span class="line">	client           kubernetes.Interface</span><br><span class="line">	namespace        string</span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">	lock             sync.Mutex</span><br><span class="line">	defaultResync    <span class="selector-tag">time</span>.Duration</span><br><span class="line">	customResync     map[reflect.Type]<span class="selector-tag">time</span>.Duration</span><br><span class="line"></span><br><span class="line">	informers map[reflect.Type]cache.SharedIndexInformer</span><br><span class="line">	<span class="comment">// startedInformers is used for tracking which informers have been started.</span></span><br><span class="line">	<span class="comment">// This allows Start() to be called multiple times safely.</span></span><br><span class="line">	startedInformers map[reflect.Type]bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这段代码的逻辑是判断informer是否已经向factory注册完成，如果没有则进行注册操作。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func (f *sharedInformerFactory) InformerFor(obj runtime<span class="selector-class">.Object</span>, newFunc internalinterfaces.NewInformerFunc) cache<span class="selector-class">.SharedIndexInformer</span> &#123;</span><br><span class="line">	f<span class="selector-class">.lock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">	defer f<span class="selector-class">.lock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"></span><br><span class="line">	informerType := reflect.TypeOf(obj)</span><br><span class="line">	informer, exists := f<span class="selector-class">.informers</span>[informerType]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		return informer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resyncPeriod, exists := f<span class="selector-class">.customResync</span>[informerType]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		resyncPeriod = f.defaultResync</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	informer = newFunc(f<span class="selector-class">.client</span>, resyncPeriod)</span><br><span class="line">	f<span class="selector-class">.informers</span>[informerType] = informer</span><br><span class="line"></span><br><span class="line">	return informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Informer-Run"><a href="#Informer-Run" class="headerlink" title="Informer Run"></a>Informer Run</h3><p>最终informerFactory将注册到工厂的所有informer都启动,Informer主要的工作就是监听事件，并分发事件。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line">func (f *sharedInformerFactory) Start(stopCh &lt;-chan struct&#123;&#125;) &#123;</span><br><span class="line">	f<span class="selector-class">.lock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">	defer f<span class="selector-class">.lock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> informerType, informer := range f<span class="selector-class">.informers</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !f<span class="selector-class">.startedInformers</span>[informerType] &#123;</span><br><span class="line">			go informer.Run(stopCh)</span><br><span class="line">			f<span class="selector-class">.startedInformers</span>[informerType] = true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而WaitForCacheSync的作用主要是确认是否所有的Informer的都已经从kubernetes接收过事件，如果已经接收到事件，那么HasSynced会被设置为true。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WaitForCacheSync waits for all started informers' cache were synced.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">WaitForCacheSync</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">map</span>[<span class="title">reflect</span>.<span class="title">Type</span>]<span class="title">bool</span></span> &#123;</span><br><span class="line">	informers := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">map</span>[<span class="title">reflect</span>.<span class="title">Type</span>]<span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">		f.lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">		informers := <span class="keyword">map</span>[reflect.Type]cache.SharedIndexInformer&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">			<span class="keyword">if</span> f.startedInformers[informerType] &#123;</span><br><span class="line">				informers[informerType] = informer</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> informers</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	res := <span class="keyword">map</span>[reflect.Type]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> informType, informer := <span class="keyword">range</span> informers &#123;</span><br><span class="line">		res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sharedIndexInformer"><a href="#sharedIndexInformer" class="headerlink" title="sharedIndexInformer"></a>sharedIndexInformer</h3><p>informer作为异步事件处理框架，完成了事件监听和分发处理两个过程，sharedIndexInformer的声明结构，该结构就是代表了一个Informer实例。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type sharedIndexInformer struct &#123;</span><br><span class="line">	indexer    Indexer</span><br><span class="line">	controller Controller</span><br><span class="line"></span><br><span class="line">	processor             *sharedProcessor</span><br><span class="line">	cacheMutationDetector CacheMutationDetector</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This block is tracked to handle late initialization of the controller</span></span><br><span class="line">	listerWatcher ListerWatcher</span><br><span class="line">	objectType    runtime.Object</span><br><span class="line"></span><br><span class="line">	<span class="comment">// resyncCheckPeriod is how often we want the reflector's resync timer to fire so it can call</span></span><br><span class="line">	<span class="comment">// shouldResync to check if any of our listeners need a resync.</span></span><br><span class="line">	resyncCheckPeriod <span class="selector-tag">time</span>.Duration</span><br><span class="line">	<span class="comment">// defaultEventHandlerResyncPeriod is the default resync period for any handlers added via</span></span><br><span class="line">	<span class="comment">// AddEventHandler (i.e. they don't specify one and just want to use the shared informer's default</span></span><br><span class="line">	<span class="comment">// value).</span></span><br><span class="line">	defaultEventHandlerResyncPeriod <span class="selector-tag">time</span>.Duration</span><br><span class="line">	<span class="comment">// clock allows for testability</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line"></span><br><span class="line">	started, stopped bool</span><br><span class="line">	startedLock      sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// blockDeltas gives a way to stop all event distribution so that a late event handler</span></span><br><span class="line">	<span class="comment">// can safely join the shared informer.</span></span><br><span class="line">	blockDeltas sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看indexer成员，该成员indexer是一个保存全量数据的缓存Store。 Informer对外提供的Lister就是直接从Store获取的数据，而没有直接操作etcd。</p>
<p>indexer的声明结构:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Indexer is a storage interface that lets you list objects using multiple indexing functions</span></span><br><span class="line"><span class="keyword">type</span> Indexer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Store</span><br><span class="line">	<span class="comment">// Retrieve list of objects that match on the named indexing function</span></span><br><span class="line">	Index(indexName <span class="built_in">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	<span class="comment">// IndexKeys returns the set of keys that match on the named indexing function.</span></span><br><span class="line">	IndexKeys(indexName, indexKey <span class="built_in">string</span>) ([]<span class="built_in">string</span>, error)</span><br><span class="line">	<span class="comment">// ListIndexFuncValues returns the list of generated values of an Index func</span></span><br><span class="line">	ListIndexFuncValues(indexName <span class="built_in">string</span>) []<span class="built_in">string</span></span><br><span class="line">	<span class="comment">// ByIndex lists object that match on the named indexing function with the exact key</span></span><br><span class="line">	ByIndex(indexName, indexKey <span class="built_in">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	<span class="comment">// GetIndexer return the indexers</span></span><br><span class="line">	GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AddIndexers adds more indexers to this store.  If you call this after you already have data</span></span><br><span class="line">	<span class="comment">// in the store, the results are undefined.</span></span><br><span class="line">	AddIndexers(newIndexers Indexers) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个代码片段是启动一个Informer实例，需要做的处理逻辑。接下来，让我们分析下这部分处理逻辑的各个细节部分。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func (s *sharedIndexInformer) Run(stopCh &lt;-chan struct&#123;&#125;) &#123;</span><br><span class="line">    	defer utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, s.indexer)</span><br><span class="line"></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">		Queue:            fifo,</span><br><span class="line">		ListerWatcher:    s<span class="selector-class">.listerWatcher</span>,</span><br><span class="line">		ObjectType:       s<span class="selector-class">.objectType</span>,</span><br><span class="line">		FullResyncPeriod: s<span class="selector-class">.resyncCheckPeriod</span>,</span><br><span class="line">		RetryOnError:     false,</span><br><span class="line">		ShouldResync:     s<span class="selector-class">.processor</span><span class="selector-class">.shouldResync</span>,</span><br><span class="line"></span><br><span class="line">		Process: s<span class="selector-class">.HandleDeltas</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	func() &#123;</span><br><span class="line">		s<span class="selector-class">.startedLock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">		defer s<span class="selector-class">.startedLock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"></span><br><span class="line">		s<span class="selector-class">.controller</span> = New(cfg)</span><br><span class="line">		s<span class="selector-class">.controller</span>.(*controller)<span class="selector-class">.clock</span> = s.clock</span><br><span class="line">		s<span class="selector-class">.started</span> = true</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">	processorStopCh := make(chan struct&#123;&#125;)</span><br><span class="line">	<span class="selector-tag">var</span> wg wait.Group</span><br><span class="line">	defer wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">	defer close(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">	wg.StartWithChannel(processorStopCh, s<span class="selector-class">.cacheMutationDetector</span><span class="selector-class">.Run</span>)</span><br><span class="line">	wg.StartWithChannel(processorStopCh, s<span class="selector-class">.processor</span><span class="selector-class">.run</span>)</span><br><span class="line"></span><br><span class="line">	defer func() &#123;</span><br><span class="line">		s<span class="selector-class">.startedLock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">		defer s<span class="selector-class">.startedLock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line">		s<span class="selector-class">.stopped</span> = true <span class="comment">// Don't want any new listeners</span></span><br><span class="line">	&#125;()</span><br><span class="line">	s<span class="selector-class">.controller</span><span class="selector-class">.Run</span>(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p>首先创建一个DeltaFIFO实例对象，该实例对象的声明结构:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> DeltaFIFO struct &#123;</span><br><span class="line">	// lock/cond protects access <span class="keyword">to</span> <span class="string">'items'</span> <span class="built_in">and</span> <span class="string">'queue'</span>.</span><br><span class="line">	lock <span class="keyword">sync</span>.RWMutex</span><br><span class="line">	cond <span class="keyword">sync</span>.Cond</span><br><span class="line"></span><br><span class="line">	// We depend <span class="keyword">on</span> the property that <span class="built_in">items</span> in the <span class="keyword">set</span> are in</span><br><span class="line">	// the queue <span class="built_in">and</span> vice versa, <span class="built_in">and</span> that <span class="keyword">all</span> Deltas in this</span><br><span class="line">	// <span class="keyword">map</span> have at least one Delta.</span><br><span class="line">	<span class="built_in">items</span> <span class="keyword">map</span>[<span class="built_in">string</span>]Deltas</span><br><span class="line">	queue []<span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">	// populated <span class="keyword">is</span> true <span class="keyword">if</span> the <span class="keyword">first</span> batch of <span class="built_in">items</span> inserted by Replace() <span class="built_in">has</span> been populated</span><br><span class="line">	// <span class="built_in">or</span> Delete/Add/Update was called <span class="keyword">first</span>.</span><br><span class="line">	populated bool</span><br><span class="line">	// initialPopulationCount <span class="keyword">is</span> the <span class="keyword">number</span> of <span class="built_in">items</span> inserted by the <span class="keyword">first</span> <span class="keyword">call</span> of Replace()</span><br><span class="line">	initialPopulationCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	// keyFunc <span class="keyword">is</span> used <span class="keyword">to</span> <span class="keyword">make</span> the key used <span class="keyword">for</span> queued item</span><br><span class="line">	// insertion <span class="built_in">and</span> retrieval, <span class="built_in">and</span> should <span class="keyword">be</span> deterministic.</span><br><span class="line">	keyFunc KeyFunc</span><br><span class="line"></span><br><span class="line">	// knownObjects <span class="keyword">list</span> <span class="built_in">keys</span> that are <span class="string">"known"</span>, <span class="keyword">for</span> the</span><br><span class="line">	// purpose of figuring out which <span class="built_in">items</span> have been deleted</span><br><span class="line">	// when Replace() <span class="built_in">or</span> Delete() <span class="keyword">is</span> called.</span><br><span class="line">	knownObjects KeyListerGetter</span><br><span class="line"></span><br><span class="line">	// Indication the queue <span class="keyword">is</span> closed.</span><br><span class="line">	// Used <span class="keyword">to</span> indicate <span class="keyword">a</span> queue <span class="keyword">is</span> closed <span class="keyword">so</span> <span class="keyword">a</span> control loop can <span class="keyword">exit</span> when <span class="keyword">a</span> queue <span class="keyword">is</span> <span class="built_in">empty</span>.</span><br><span class="line">	// Currently, not used <span class="keyword">to</span> gate any of CRED operations.</span><br><span class="line">	closed     bool</span><br><span class="line">	closedLock <span class="keyword">sync</span>.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Informer中,DeltaFIFO作为Reflector的Store,根据List/Watch的结果对Store进行ADD,UPDATE,DELETE操作。在Delta的声明结构中，最重要的就是两个成员<code>iterms</code>和<code>queue</code>。iterms成员缓存了所有添加到Store中的事件，而queue则存储这些事件的id作为FIFO处理的先后顺序。而<code>populated</code>和<code>initialPopulationCount</code>两个成员主要当Store被首次初始化完成之后，会被设置为true。</p>
<p>iterms的声明结构:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	Added   DeltaType = <span class="string">"Added"</span></span><br><span class="line">	Updated DeltaType = <span class="string">"Updated"</span></span><br><span class="line">	Deleted DeltaType = <span class="string">"Deleted"</span></span><br><span class="line">	// The other types are obvious. You<span class="symbol">'ll</span> get Sync deltas <span class="keyword">when</span>:</span><br><span class="line">	//  * A watch expires/errors <span class="keyword">out</span> <span class="keyword">and</span> a <span class="keyword">new</span> list/watch cycle <span class="keyword">is</span> started.</span><br><span class="line">	//  * You<span class="symbol">'ve</span> turned on periodic syncs.</span><br><span class="line">	// (Anything that trigger<span class="symbol">'s</span> DeltaFIFO<span class="symbol">'s</span> Replace() method.)</span><br><span class="line">	Sync DeltaType = <span class="string">"Sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// <span class="keyword">Delta</span> <span class="keyword">is</span> the <span class="keyword">type</span> <span class="type">stored </span>by a DeltaFIFO. It tells you what change</span><br><span class="line">// happened, <span class="keyword">and</span> the object<span class="symbol">'s</span> state after* that change.</span><br><span class="line">//</span><br><span class="line">// [*] Unless the change <span class="keyword">is</span> a deletion, <span class="keyword">and</span> <span class="keyword">then</span> you<span class="symbol">'ll</span> get the final</span><br><span class="line">//     state <span class="keyword">of</span> the object before it was deleted.</span><br><span class="line"><span class="keyword">type</span> <span class="type">Delta </span>struct &#123;</span><br><span class="line">	<span class="keyword">Type</span>   <span class="type">DeltaType</span></span><br><span class="line"><span class="type">	</span>Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Deltas <span class="keyword">is</span> a list <span class="keyword">of</span> one <span class="keyword">or</span> more <span class="symbol">'Delta</span><span class="symbol">'s</span> to an individual object.</span><br><span class="line">// The oldest <span class="keyword">delta</span> <span class="keyword">is</span> <span class="keyword">at</span> index <span class="number">0</span>, the newest <span class="keyword">delta</span> <span class="keyword">is</span> the last one.</span><br><span class="line"><span class="keyword">type</span> <span class="type">Deltas </span>[]<span class="keyword">Delta</span></span><br></pre></td></tr></table></figure>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>当初始化DeltaFIFO实例之后，就对controller的Config进行初始化操作,Config的声明结构:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config contains all the settings for a Controller.</span></span><br><span class="line">type Config struct &#123;</span><br><span class="line">	<span class="comment">// The queue for your objects - has to be a DeltaFIFO due to</span></span><br><span class="line">	<span class="comment">// assumptions in the implementation. Your Process() function</span></span><br><span class="line">	<span class="comment">// should accept the output of this Queue's Pop() method.</span></span><br><span class="line">	Queue</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Something that can list and watch your objects.</span></span><br><span class="line">	ListerWatcher</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Something that can process your objects.</span></span><br><span class="line">	Process ProcessFunc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The type of your objects.</span></span><br><span class="line">	ObjectType runtime.Object</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reprocess everything at least this often.</span></span><br><span class="line">	<span class="comment">// Note that if it takes longer for you to clear the queue than this</span></span><br><span class="line">	<span class="comment">// period, you will end up processing items in the order determined</span></span><br><span class="line">	<span class="comment">// by FIFO.Replace(). Currently, this is random. If this is a</span></span><br><span class="line">	<span class="comment">// problem, we can change that replacement policy to append new</span></span><br><span class="line">	<span class="comment">// things to the end of the queue instead of replacing the entire</span></span><br><span class="line">	<span class="comment">// queue.</span></span><br><span class="line">	FullResyncPeriod <span class="selector-tag">time</span>.Duration</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ShouldResync, if specified, is invoked when the controller's reflector determines the next</span></span><br><span class="line">	<span class="comment">// periodic sync should occur. If this returns true, it means the reflector should proceed with</span></span><br><span class="line">	<span class="comment">// the resync.</span></span><br><span class="line">	ShouldResync ShouldResyncFunc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If true, when Process() returns an error, re-enqueue the object.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> add interface to let you inject a delay/backoff or drop</span></span><br><span class="line">	<span class="comment">//       the object completely if desired. Pass the object in</span></span><br><span class="line">	<span class="comment">//       question to this interface as a parameter.</span></span><br><span class="line">	RetryOnError bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对Config中的主要成员进行介绍下，方便之后介绍controller的时候方便了解。</p>
<ul>
<li>Queue: DeltaFIFO事件处理队列，之后Queue的POP方法会从该队列中不断的POP数据给Process()方法去处理。</li>
<li>ListerWatcher: 用于List/Watch关心的kubernetes资源对象。</li>
<li>Process: 就是处理从DeltaFIFO中POP出来的数据，这个具体的实现后续会介绍到。</li>
</ul>
<p>最终对Config初始化完成之后，赋值给sharedIndexInformer的controller成员。</p>
<p>Controller的Run主要是一个生产者消费者模式，reflector是生产者，为controller中的Process方法<code>Process: s.HandleDeltas</code>是消费者。而processLoop会循环的从Queue(DeltaFIFO)中POP事件数据给s.HandleDeltas去处理。</p>
<p>Controller Run的代码片段如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run begins processing items, and will continue until a value is sent down stopCh.</span></span><br><span class="line"><span class="comment">// It's an error to call Run more than once.</span></span><br><span class="line"><span class="comment">// Run blocks; call via go.</span></span><br><span class="line">func (c *controller) Run(stopCh &lt;-chan struct&#123;&#125;) &#123;</span><br><span class="line">	defer utilruntime.HandleCrash()</span><br><span class="line">	go func() &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		c<span class="selector-class">.config</span><span class="selector-class">.Queue</span><span class="selector-class">.Close</span>()</span><br><span class="line">	&#125;()</span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c<span class="selector-class">.config</span><span class="selector-class">.ListerWatcher</span>,</span><br><span class="line">		c<span class="selector-class">.config</span><span class="selector-class">.ObjectType</span>,</span><br><span class="line">		c<span class="selector-class">.config</span><span class="selector-class">.Queue</span>,</span><br><span class="line">		c<span class="selector-class">.config</span><span class="selector-class">.FullResyncPeriod</span>,</span><br><span class="line">	)</span><br><span class="line">	r<span class="selector-class">.ShouldResync</span> = c<span class="selector-class">.config</span><span class="selector-class">.ShouldResync</span></span><br><span class="line">	r<span class="selector-class">.clock</span> = c.clock</span><br><span class="line"></span><br><span class="line">	c<span class="selector-class">.reflectorMutex</span><span class="selector-class">.Lock</span>()</span><br><span class="line">	c<span class="selector-class">.reflector</span> = r</span><br><span class="line">	c<span class="selector-class">.reflectorMutex</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">var</span> wg wait.Group</span><br><span class="line">	defer wg.Wait()</span><br><span class="line"></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">	wait.Until(c<span class="selector-class">.processLoop</span>, <span class="selector-tag">time</span><span class="selector-class">.Second</span>, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的这段代码片段中，首先会先启动reflector来List/Watch我们所关心的资源，并将其添加到Store(DeltaFIFO)中。具体的实现逻辑如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflector watches a specified resource and causes all changes to be reflected in the given store.</span></span><br><span class="line">type Reflector struct &#123;</span><br><span class="line">	<span class="comment">// name identifies this reflector. By default it will be a file:line if possible.</span></span><br><span class="line">	name string</span><br><span class="line">	<span class="comment">// metrics tracks basic metric information about the reflector</span></span><br><span class="line">	metrics *reflectorMetrics</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The type of object we expect to place in the store.</span></span><br><span class="line">	expectedType reflect.Type</span><br><span class="line">	<span class="comment">// The destination to sync up with the watch source</span></span><br><span class="line">	store Store</span><br><span class="line">	<span class="comment">// listerWatcher is used to perform lists and watches.</span></span><br><span class="line">	listerWatcher ListerWatcher</span><br><span class="line">	<span class="comment">// period controls timing between one watch ending and</span></span><br><span class="line">	<span class="comment">// the beginning of the next one.</span></span><br><span class="line">	period       <span class="selector-tag">time</span>.Duration</span><br><span class="line">	resyncPeriod <span class="selector-tag">time</span>.Duration</span><br><span class="line">	ShouldResync func() bool</span><br><span class="line">	<span class="comment">// clock allows tests to manipulate time</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line">	<span class="comment">// lastSyncResourceVersion is the resource version token last</span></span><br><span class="line">	<span class="comment">// observed when doing a sync with the underlying store</span></span><br><span class="line">	<span class="comment">// it is thread safe, but not synchronized with the underlying store</span></span><br><span class="line">	lastSyncResourceVersion string</span><br><span class="line">	<span class="comment">// lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion</span></span><br><span class="line">	lastSyncResourceVersionMutex sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对Reflector对象的初始化逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewNamedReflector(naming.GetNameFromCallsite(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">	reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">	r := &amp;Reflector&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		<span class="comment">// we need this to be unique per process (some names are still the same) but obvious who it belongs to</span></span><br><span class="line">		metrics:       newReflectorMetrics(makeValidPrometheusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">		listerWatcher: lw,</span><br><span class="line">		store:         store,</span><br><span class="line">		expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">		period:        time.Second,</span><br><span class="line">		resyncPeriod:  resyncPeriod,</span><br><span class="line">		clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Reflector初始化完成之后，则启动Reflector来让它去帮助你去List/Watch工作。具体的启动实现逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts a watch and handles watch events. Will restart the watch if it is closed.</span></span><br><span class="line"><span class="comment">// Run will exit when stopCh is closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedType, r.resyncPeriod, r.name)</span><br><span class="line">	wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, r.period, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的核心就是通过<code>r.ListAndWatch</code>方法去List/Watch。由于<code>r.ListAndWatch</code>实现逻辑太长，就简单的说下它的实现逻辑,这个方法主要做两件事儿:</p>
<ol>
<li>list所有关心的资源对象，并将对象存储到Store中。</li>
<li>watch所关心的资源对象, 并判断对象是否已经存在Store,如果存在则UPDATE,否则添加，或者删除。</li>
</ol>
<p>ok,这样现在通过Reflector这个生产者，我们就把我们所关心的资源对象添加到Store(DeltaFIFO)中了。接下来通过我们的Process方法来从Queue中POP出事件数据，进行消费处理。</p>
<p>processLoop的处理逻辑代码片段如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func (c *controller) processLoop() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		obj, err := c<span class="selector-class">.config</span><span class="selector-class">.Queue</span><span class="selector-class">.Pop</span>(PopProcessFunc(c<span class="selector-class">.config</span><span class="selector-class">.Process</span>))</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			<span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c<span class="selector-class">.config</span><span class="selector-class">.RetryOnError</span> &#123;</span><br><span class="line">				<span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">				c<span class="selector-class">.config</span><span class="selector-class">.Queue</span><span class="selector-class">.AddIfNotPresent</span>(obj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>process会不断的从Queue中POP事件数据给c.config.Process消费。如果在消费的过程中出现错误的情况，则还会重新的把数据重新加回到queue队列中。</p>
<p>queue.POP方法的实现逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">			<span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">			<span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">			<span class="keyword">if</span> f.IsClosed() &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, FIFOClosedError</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f.cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		id := f.queue[<span class="number">0</span>]</span><br><span class="line">		f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">			f.initialPopulationCount--</span><br><span class="line">		&#125;</span><br><span class="line">		item, ok := f.items[id]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">delete</span>(f.items, id)</span><br><span class="line">		err := process(item)</span><br><span class="line">		<span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">			f.addIfNotPresent(id, item)</span><br><span class="line">			err = e.Err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">		<span class="comment">// ownership to the caller.</span></span><br><span class="line">		<span class="keyword">return</span> item, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c.config.Process(就是HandleDeltas)方法的处理逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s.blockDeltas.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// from oldest to newest</span></span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">		<span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">			isSync := d.Type == Sync</span><br><span class="line">			s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">			<span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> Deleted:</span><br><span class="line">			<span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当从Queue队列中POP出新的事件数据时，都会被上面的这个方法处理，首先会根据元素的处理类型,来决定具体的处理逻辑:</p>
<p>下面是每个事件元素能够被处理的时间类型:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	Added   DeltaType = <span class="string">"Added"</span></span><br><span class="line">	Updated DeltaType = <span class="string">"Updated"</span></span><br><span class="line">	Deleted DeltaType = <span class="string">"Deleted"</span></span><br><span class="line">	<span class="regexp">//</span> The other types are obvious. Yo<span class="string">u'll get Sync deltas when:</span></span><br><span class="line"><span class="string">	//  * A watch expires/errors out and a new list/watch cycle is started.</span></span><br><span class="line"><span class="string">	//  * You'</span>ve turned on periodic syncs.</span><br><span class="line">	<span class="regexp">//</span> (Anything that trigge<span class="string">r's DeltaFIFO'</span>s Replace() method.)</span><br><span class="line">	Sync DeltaType = <span class="string">"Sync"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果是<code>Sync</code>,<code>ADD</code>,<code>Updated</code>,<code>DELETE</code>则相应的处理逻辑如下:</p>
<p>1.如果是ADD类型，则直接将新添加的元素ADD到Store中，之后进行事件的分发distribute操作。<br>2.如果是UPDATED类型，则从Store中获取该元素，并更新Store中的元素，之后进行事件的分发distribute操作。<br>3.如果是DELETE类型，则直接从Store中删除元素，之后也是进行事件的分发distribute操作。</p>
<h3 id="sharedProcessor"><a href="#sharedProcessor" class="headerlink" title="sharedProcessor"></a>sharedProcessor</h3><p>接下来我们在对sharedProcessor的事件分发处理进行详细的介绍。在消费事件时，通过informer的processer进行distrubute。processer进行分发的处理函数由外部的<code>AddEventHandler</code>向processer里addListener。其中addListener只是添加一个processer管理listeners,并在分发时遍历listeners，将事件发送给所有的listener。</p>
<p>sharedProcessor的声明结构如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type sharedProcessor struct &#123;</span><br><span class="line">	listenersStarted bool</span><br><span class="line">	listenersLock    sync.RWMutex</span><br><span class="line">	listeners        []*processorListener</span><br><span class="line">	syncingListeners []*processorListener</span><br><span class="line">	clock            clock.Clock</span><br><span class="line">	wg               wait.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">p</span> *sharedProcessor) addListener(listener *processorListener) &#123;</span><br><span class="line">	<span class="selector-tag">p</span><span class="selector-class">.listenersLock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">	defer <span class="selector-tag">p</span><span class="selector-class">.listenersLock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">p</span>.addListenerLocked(listener)</span><br><span class="line">	<span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.listenersStarted</span> &#123;</span><br><span class="line">		<span class="selector-tag">p</span><span class="selector-class">.wg</span><span class="selector-class">.Start</span>(listener.run)</span><br><span class="line">		<span class="selector-tag">p</span><span class="selector-class">.wg</span><span class="selector-class">.Start</span>(listener.pop)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">p</span> *sharedProcessor) distribute(obj interface&#123;&#125;, sync bool) &#123;</span><br><span class="line">	<span class="selector-tag">p</span><span class="selector-class">.listenersLock</span><span class="selector-class">.RLock</span>()</span><br><span class="line">	defer <span class="selector-tag">p</span><span class="selector-class">.listenersLock</span><span class="selector-class">.RUnlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sync &#123;</span><br><span class="line">		<span class="keyword">for</span> _, listener := range <span class="selector-tag">p</span><span class="selector-class">.syncingListeners</span> &#123;</span><br><span class="line">			listener.add(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, listener := range <span class="selector-tag">p</span><span class="selector-class">.listeners</span> &#123;</span><br><span class="line">			listener.add(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processor的run保证所有listener都开始运行，并保证退出时所有listener的chan都关闭。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="selector-tag">p</span> *sharedProcessor) run(stopCh &lt;-chan struct&#123;&#125;) &#123;</span><br><span class="line">	func() &#123;</span><br><span class="line">		<span class="selector-tag">p</span><span class="selector-class">.listenersLock</span><span class="selector-class">.RLock</span>()</span><br><span class="line">		defer <span class="selector-tag">p</span><span class="selector-class">.listenersLock</span><span class="selector-class">.RUnlock</span>()</span><br><span class="line">		<span class="keyword">for</span> _, listener := range <span class="selector-tag">p</span><span class="selector-class">.listeners</span> &#123;</span><br><span class="line">			<span class="selector-tag">p</span><span class="selector-class">.wg</span><span class="selector-class">.Start</span>(listener.run)</span><br><span class="line">			<span class="selector-tag">p</span><span class="selector-class">.wg</span><span class="selector-class">.Start</span>(listener.pop)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="selector-tag">p</span><span class="selector-class">.listenersStarted</span> = true</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-stopCh</span><br><span class="line">	<span class="selector-tag">p</span><span class="selector-class">.listenersLock</span><span class="selector-class">.RLock</span>()</span><br><span class="line">	defer <span class="selector-tag">p</span><span class="selector-class">.listenersLock</span><span class="selector-class">.RUnlock</span>()</span><br><span class="line">	<span class="keyword">for</span> _, listener := range <span class="selector-tag">p</span><span class="selector-class">.listeners</span> &#123;</span><br><span class="line">		close(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-tag">p</span><span class="selector-class">.wg</span><span class="selector-class">.Wait</span>() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="processorListener"><a href="#processorListener" class="headerlink" title="processorListener"></a>processorListener</h3><p>processorListener的声明结构:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type processorListener struct &#123;</span><br><span class="line">	nextCh chan interface&#123;&#125;</span><br><span class="line">	addCh  chan interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">	handler ResourceEventHandler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pendingNotifications is an unbounded ring buffer that holds all notifications not yet distributed.</span></span><br><span class="line">	<span class="comment">// There is one per listener, but a failing/stalled listener will have infinite pendingNotifications</span></span><br><span class="line">	<span class="comment">// added until we OOM.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> This is no worse than before, since reflectors were backed by unbounded DeltaFIFOs, but</span></span><br><span class="line">	<span class="comment">// we should try to do something better.</span></span><br><span class="line">	pendingNotifications buffer.RingGrowing</span><br><span class="line"></span><br><span class="line">	<span class="comment">// requestedResyncPeriod is how frequently the listener wants a full resync from the shared informer</span></span><br><span class="line">	requestedResyncPeriod <span class="selector-tag">time</span>.Duration</span><br><span class="line">	<span class="comment">// resyncPeriod is how frequently the listener wants a full resync from the shared informer. This</span></span><br><span class="line">	<span class="comment">// value may differ from requestedResyncPeriod if the shared informer adjusts it to align with the</span></span><br><span class="line">	<span class="comment">// informer's overall resync check period.</span></span><br><span class="line">	resyncPeriod <span class="selector-tag">time</span>.Duration</span><br><span class="line">	<span class="comment">// nextResync is the earliest time the listener should get a full resync</span></span><br><span class="line">	nextResync <span class="selector-tag">time</span>.Time</span><br><span class="line">	<span class="comment">// resyncLock guards access to resyncPeriod and nextResync</span></span><br><span class="line">	resyncLock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pendingNotifications装了所有还没分发的事件。而handler则是开发者向Informer注册的ResourceEventHandler。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type ResourceEventHandler<span class="built_in"> interface </span>&#123;</span><br><span class="line">	OnAdd(obj interface&#123;&#125;)</span><br><span class="line">	OnUpdate(oldObj, newObj interface&#123;&#125;)</span><br><span class="line">	OnDelete(obj interface&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而ResourceEventHandler这个接口被ResourceEventHandlerFuncs结构已经实现了，开发者去实现下面的<code>AddFunc</code>, <code>UpdateFunc</code>, <code>DeleteFunc</code>并注册到Informer即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type <span class="type">ResourceEventHandlerFuncs</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">	<span class="type">AddFunc</span>    <span class="function"><span class="keyword">func</span><span class="params">(obj interface&#123;&#125;)</span></span></span><br><span class="line">	<span class="type">UpdateFunc</span> <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj interface&#123;&#125;)</span></span></span><br><span class="line">	<span class="type">DeleteFunc</span> <span class="function"><span class="keyword">func</span><span class="params">(obj interface&#123;&#125;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来继续，其中处理事件processor开始distribute时，会调用listener的add方法，将事件发到addCh上。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="selector-tag">p</span> *processorListener) add(notification interface&#123;&#125;) &#123;</span><br><span class="line">	<span class="selector-tag">p</span><span class="selector-class">.addCh</span> &lt;- notification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>listener的pop goroutine不断地从addCh中获取事件，写到本地的pendingNotification或写给nextCh，而nextCh从本地pendingNotification或addCh获取事件。最后由run方法消费事件和分发事件。run方法支持指数重试，退出也会重新开始。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="selector-tag">p</span> *processorListener) pop() &#123;</span><br><span class="line">	defer utilruntime.HandleCrash()</span><br><span class="line">	defer close(<span class="selector-tag">p</span>.nextCh) <span class="comment">// Tell .run() to stop</span></span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">var</span> nextCh chan&lt;- interface&#123;&#125;</span><br><span class="line">	<span class="selector-tag">var</span> notification interface&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case nextCh &lt;- notification:</span><br><span class="line">			<span class="comment">// Notification dispatched</span></span><br><span class="line">			<span class="selector-tag">var</span> ok bool</span><br><span class="line">			notification, ok = <span class="selector-tag">p</span><span class="selector-class">.pendingNotifications</span><span class="selector-class">.ReadOne</span>()</span><br><span class="line">			<span class="keyword">if</span> !ok &#123; <span class="comment">// Nothing to pop</span></span><br><span class="line">				nextCh = nil <span class="comment">// Disable this select case</span></span><br><span class="line">			&#125;</span><br><span class="line">		case notificationToAdd, ok := &lt;-<span class="selector-tag">p</span><span class="selector-class">.addCh</span>:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> notification == nil &#123; <span class="comment">// No notification to pop (and pendingNotifications is empty)</span></span><br><span class="line">				<span class="comment">// Optimize the case - skip adding to pendingNotifications</span></span><br><span class="line">				notification = notificationToAdd</span><br><span class="line">				nextCh = <span class="selector-tag">p</span>.nextCh</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// There is already a notification waiting to be dispatched</span></span><br><span class="line">				<span class="selector-tag">p</span><span class="selector-class">.pendingNotifications</span><span class="selector-class">.WriteOne</span>(notificationToAdd)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">p</span> *processorListener) run() &#123;</span><br><span class="line">	<span class="comment">// this call blocks until the channel is closed.  When a panic happens during the notification</span></span><br><span class="line">	<span class="comment">// we will catch it, **the offending item will be skipped!**, and after a short delay (one second)</span></span><br><span class="line">	<span class="comment">// the next notification will be attempted.  This is usually better than the alternative of never</span></span><br><span class="line">	<span class="comment">// delivering again.</span></span><br><span class="line">	stopCh := make(chan struct&#123;&#125;)</span><br><span class="line">	wait.Until(func() &#123;</span><br><span class="line">		<span class="comment">// this gives us a few quick retries before a long pause and then a few more quick retries</span></span><br><span class="line">		err := wait.ExponentialBackoff(retry<span class="selector-class">.DefaultRetry</span>, func() (bool, error) &#123;</span><br><span class="line">			<span class="keyword">for</span> next := range <span class="selector-tag">p</span><span class="selector-class">.nextCh</span> &#123;</span><br><span class="line">				switch notification := next.(type) &#123;</span><br><span class="line">				case updateNotification:</span><br><span class="line">					<span class="selector-tag">p</span><span class="selector-class">.handler</span><span class="selector-class">.OnUpdate</span>(notification<span class="selector-class">.oldObj</span>, notification.newObj)</span><br><span class="line">				case addNotification:</span><br><span class="line">					<span class="selector-tag">p</span><span class="selector-class">.handler</span><span class="selector-class">.OnAdd</span>(notification.newObj)</span><br><span class="line">				case deleteNotification:</span><br><span class="line">					<span class="selector-tag">p</span><span class="selector-class">.handler</span><span class="selector-class">.OnDelete</span>(notification.oldObj)</span><br><span class="line">				default:</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">"unrecognized notification: %#v"</span>, next))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// the only way to get here is if the p.nextCh is empty and closed</span></span><br><span class="line">			return true, nil</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// the only way to get here is if the p.nextCh is empty and closed</span></span><br><span class="line">		<span class="keyword">if</span> err == nil &#123;</span><br><span class="line">			close(stopCh)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">1</span>*<span class="selector-tag">time</span><span class="selector-class">.Minute</span>, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就对Store中的事件数据进行了分发，如果开发者想要实现自己的custom controller的话，可以在分发之后，将分发后的数据写入到client-go提供的Workqueue队列中，并在自己实现的syncHandler实现逻辑中不断的中Workqueue中去获取key,然后去实现自己的逻辑。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面详细的介绍了client-go的实现逻辑。深入的了解client-go的实现逻辑对于之后开发自定义controller也好，还是看kube-controller-manager源码也好(由于kube-controller-manager是一个controller的集合，用于管理kubernetes上的各类资源)。都会有一定的帮助。并且它的这种设计理念也是值得去学习的：）</p>
<h3 id="更多有益的资源"><a href="#更多有益的资源" class="headerlink" title="更多有益的资源"></a>更多有益的资源</h3><ul>
<li><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></li>
<li><a href="https://blog.openshift.com/kubernetes-deep-dive-code-generation-customresources/" target="_blank" rel="noopener">https://blog.openshift.com/kubernetes-deep-dive-code-generation-customresources/</a></li>
<li><a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/</a></li>
</ul>
</div><div class="tags"><a href="/tags/kubernetes/">kubernetes</a></div><div class="post-nav"><a class="pre" href="/2019/10/11/etcd-cluster-on-kubernetes/">Etcd Cluster on Kubernetes</a><a class="next" href="/2019/08/25/coredns/">CoreDNS源码分析</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '86d1945e3a9358946043',
  clientSecret: '304f48ee3394ae5dab75d19a966506e170d850f6',
  repo: 'xigang.github.io',
  owner: 'xigang',
  admin: ['xigang'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://github.com/xigang"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etcd/">etcd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubernetes/">kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/microservices/">microservices</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志监控/">日志监控</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/etcd/" style="font-size: 15px;">etcd</a> <a href="/tags/prometheus/" style="font-size: 15px;">prometheus</a> <a href="/tags/alertmanager/" style="font-size: 15px;">alertmanager</a> <a href="/tags/bosun/" style="font-size: 15px;">bosun</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/cgroup/" style="font-size: 15px;">cgroup</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/dns/" style="font-size: 15px;">dns</a> <a href="/tags/coredns/" style="font-size: 15px;">coredns</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/kapacitor/" style="font-size: 15px;">kapacitor</a> <a href="/tags/kubeflow/" style="font-size: 15px;">kubeflow</a> <a href="/tags/scheduler/" style="font-size: 15px;">scheduler</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/microservices/" style="font-size: 15px;">microservices</a> <a href="/tags/kube-dns/" style="font-size: 15px;">kube-dns</a> <a href="/tags/ipvs/" style="font-size: 15px;">ipvs</a> <a href="/tags/iptables/" style="font-size: 15px;">iptables</a> <a href="/tags/netfilter/" style="font-size: 15px;">netfilter</a> <a href="/tags/lxcfs/" style="font-size: 15px;">lxcfs</a> <a href="/tags/mxnet/" style="font-size: 15px;">mxnet</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/kube-apisever/">Kube-apisever启动流程及API安装源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/lxcfs-admission-webhook/">使用Lxcfs和kubernetes Admission Webhook实现对容器资源可视化隔离</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/11/etcd-cluster-on-kubernetes/">Etcd Cluster on Kubernetes</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/21/client-go/">Kubernetes Client-Go Informer 实现源码剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/coredns/">CoreDNS源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/dns/">A DNS Refresher</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/kube-proxy-source-code/">Kube-Proxy  IPVS模式源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/kubernetes-service/">浅谈Kubernetes Service负载均衡实现机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/cgroupv2/">CGROUPS VERSION 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/11/bosun/">Prometheus基于bosun框架进行告警</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://gogap.cn/" title="gogap" target="_blank">gogap</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">xigang's home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>