<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CoreDNS源码分析 | xigang's home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CoreDNS源码分析</h1><a id="logo" href="/.">xigang's home</a><p class="description">Do it right or don't do it at all</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CoreDNS源码分析</h1><div class="post-meta">Aug 25, 2019<span> | </span><span class="category"><a href="/categories/network/">network</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>在Kubernetes 1.13版本以后(包含1.13),Kubernetes便指定了CoreDNS作为默认的服务发现机制(之前默认的版本是<a href="https://xigang.github.io/2018/11/24/kube-dns/" target="_blank" rel="noopener">Kube-DNS</a>)，由于项目中也需要使用CoreDNS对Service进行DNS解析，所以在使用CoreDNS的过程，便深入的看下CoreDNS的源码，已对其内部的实现机制有所了解。</p>
<p>CoreDNS版本: CoreDNS-1.6.2</p>
<h3 id="CoreDNS-的安装及使用"><a href="#CoreDNS-的安装及使用" class="headerlink" title="CoreDNS 的安装及使用"></a>CoreDNS 的安装及使用</h3><p>对于CoreDNS的安装及使用方式这里就不做详细的介绍了，具体详情请参考:</p>
<ul>
<li><a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/coredns">Install CoreDNS</a></li>
<li><a href="https://coredns.io/manual/toc/" target="_blank" rel="noopener">How to use CoreDNS?</a></li>
</ul>
<h3 id="CoreDNS-源码分析"><a href="#CoreDNS-源码分析" class="headerlink" title="CoreDNS 源码分析"></a>CoreDNS 源码分析</h3><p>CoreDNS是一个基于<a href="https://github.com/caddyserver/caddy">caddy</a>框架实现的，整个项目大量的使用了Caddy的插件功能，接下来直接分析源码，下面这张图(图片源自网络)就是CoreDNS整体框架启动流程的一个结构:</p>
<div align="left"><br><img src="http://p1.qhimg.com/t01d78be440cfa6b4fd.png" width="800" height="800" alt="coredns"><br></div>

<p>首先在CoreDNS的main.go文件中，会对plugin package进行import，用来将所有的plugin进行register。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="comment">// Plug in CoreDNS</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/core/plugin"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>接下来我们看下<code>github.com/coredns/coredns/core/plugin/zplugin.go</code>文件的内容(需要注意的是<code>zplugin.go</code>文件是Makefile通过<code>plugin.cfg</code>自动生成的, 而CoreDNS会基于<code>plugin.cfg</code>文件中的指令顺序，按顺序进行插件的执行)。</p>
<p>Makefile通过<code>plugin.cfg</code>生成的指令如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core/plugin/zplugin<span class="selector-class">.go</span> core/dnsserver/zdirectives<span class="selector-class">.go</span>: plugin<span class="selector-class">.cfg</span> GO111MODULE=on go generate coredns.go</span><br></pre></td></tr></table></figure>
<p><code>zplugin.go</code>文件的内容如下:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generated by directives_generate.go; DO NOT EDIT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="comment">// Include all plugins.</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/caddyserver/caddy/onevent"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/any"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/auto"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/autopath"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/azure"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/bind"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/cache"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/cancel"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/chaos"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/debug"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/dnssec"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/dnstap"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/erratic"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/errors"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/etcd"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/federation"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/file"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/forward"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/grpc"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/health"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/hosts"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/k8s_external"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/kubernetes"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/loadbalance"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/log"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/loop"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/metadata"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/metrics"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/nsid"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/pprof"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/ready"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/reload"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/rewrite"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/root"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/route53"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/secondary"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/template"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/tls"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/trace"</span></span><br><span class="line">	<span class="literal">_</span> <span class="string">"github.com/coredns/coredns/plugin/whoami"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在plugin package中的每一个plugin的init()都会在程序启动之前被执行，进行plugin的注册。让我们来看kuernetes plugin的注册过程:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">init</span>() &#123;</span><br><span class="line">	<span class="selector-tag">caddy</span><span class="selector-class">.RegisterPlugin</span>(<span class="string">"kubernetes"</span>, caddy.Plugin&#123;</span><br><span class="line">		<span class="attribute">ServerType</span>: <span class="string">"dns"</span>,</span><br><span class="line">		<span class="attribute">Action</span>:     setup,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>caddy.Plugin结构包含了被注册的plugin的基本信息,包括注册的服务类型(在CoreDNS中的服务类型是<code>dns</code>)和请求这个plugin时,这个plugin该做的Action。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Plugin <span class="keyword">is</span> a <span class="keyword">type</span> <span class="type">which </span>holds information about a plugin.</span><br><span class="line"><span class="keyword">type</span> <span class="type">Plugin </span>struct &#123;</span><br><span class="line">	// ServerType <span class="keyword">is</span> the <span class="keyword">type</span> <span class="type">of </span>server this plugin <span class="keyword">is</span> <span class="keyword">for</span>.</span><br><span class="line">	// Can be empty <span class="keyword">if</span> <span class="keyword">not</span> applicable, <span class="keyword">or</span> <span class="keyword">if</span> the plugin</span><br><span class="line">	// can associate <span class="keyword">with</span> any server <span class="keyword">type</span>.</span><br><span class="line">	ServerType string</span><br><span class="line"></span><br><span class="line">	// Action <span class="keyword">is</span> the plugin<span class="symbol">'s</span> setup <span class="keyword">function</span>, <span class="keyword">if</span> associated</span><br><span class="line">	// <span class="keyword">with</span> a directive <span class="keyword">in</span> the Caddyfile.</span><br><span class="line">	Action SetupFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>caddy.RegisterPlugin方法的作用:</p>
<p>将指定plugin name(本示例:kubernetes)注册到服务类型为DNS的CoreDNS服务中。最终所有被注册plugin的存储结构为:</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// plugins <span class="keyword">is</span> a <span class="keyword">map</span> <span class="keyword">of</span> server <span class="keyword">type</span> <span class="keyword">to</span> <span class="keyword">map</span> <span class="keyword">of</span> plugin name <span class="keyword">to</span></span><br><span class="line">// Plugin. These are the <span class="string">"general"</span> plugins that may <span class="keyword">or</span> may</span><br><span class="line">// <span class="keyword">not</span> be associated <span class="keyword">with</span> a specific server <span class="keyword">type</span>. <span class="keyword">If</span> it<span class="symbol">'s</span></span><br><span class="line">// applicable <span class="keyword">to</span> multiple server types <span class="keyword">or</span> the server <span class="keyword">type</span> <span class="keyword">is</span></span><br><span class="line">// irrelevant, the key <span class="keyword">is</span> empty <span class="built_in">string</span> (<span class="string">""</span>). But <span class="keyword">all</span> plugins</span><br><span class="line">// must have a name.</span><br><span class="line">plugins = make(<span class="keyword">map</span>[<span class="built_in">string</span>]<span class="keyword">map</span>[<span class="built_in">string</span>]Plugin)</span><br></pre></td></tr></table></figure>
<p>因此，通过上面的这个过程就把CoreDNS需要的所有的plugin都注册到了<code>plugins = make(map[string]map[string]Plugin)</code>结构中，用于后续的使用。</p>
<p>注册完所有的plugin之后,开始执行main方法,该方法很简洁，只会去调用一个<code>coremain.Run()</code>方法，在run.go文件的import package中会存在一个如下的package:</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (<span class="string">"github.com/coredns/coredns/core/dnsserver"</span>)</span><br></pre></td></tr></table></figure>
<p>这个package会向CoreDNS注册一个叫做<code>dns</code>的服务类型，并关联与这个<code>dns</code>服务类型相关的一些操作:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;Port, serverType+<span class="string">".port"</span>, DefaultPort, <span class="string">"Default port"</span>)</span><br><span class="line"></span><br><span class="line">	caddy.RegisterServerType(serverType, caddy.ServerType&#123;</span><br><span class="line">		Directives: <span class="function"><span class="keyword">func</span><span class="params">()</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> Directives &#125;,</span><br><span class="line">		DefaultInput: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">caddy</span>.<span class="title">Input</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> caddy.CaddyfileInput&#123;</span><br><span class="line">				Filepath:       <span class="string">"Corefile"</span>,</span><br><span class="line">				Contents:       []<span class="keyword">byte</span>(<span class="string">".:"</span> + Port + <span class="string">" &#123;\nwhoami\n&#125;\n"</span>),</span><br><span class="line">				ServerTypeName: serverType,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		NewContext: newContext,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>caddy.ServerType包含一些服务类型相关的信息。包括:</p>
<ul>
<li>一个指令列表的函数声明,这个指令列表定义在<code>github.com/coredns/coredns/core/dnsserver/zdirectives.go</code>文件中，并且也是通过Makefile的方式自动生成。并按照指令类别的顺序依次执行。</li>
<li>一个加载默认Corefile默认配置文件的函数声明（input中包含了配置文件的<code>内容</code>， <code>路径</code>以及所属的服务类型等信息）</li>
<li>一个用于服务实例启动的Context函数声明</li>
</ul>
<p>具体的定义如下结构:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServerType contains information about a server type.</span></span><br><span class="line">type <span class="type">ServerType</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Function that returns the list of directives, in</span></span><br><span class="line">	<span class="comment">// execution order, that are valid for this server</span></span><br><span class="line">	<span class="comment">// type. Directives should be one word if possible</span></span><br><span class="line">	<span class="comment">// and lower-cased.</span></span><br><span class="line">	<span class="type">Directives</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> []string</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DefaultInput returns a default config input if none</span></span><br><span class="line">	<span class="comment">// is otherwise loaded. This is optional, but highly</span></span><br><span class="line">	<span class="comment">// recommended, otherwise a blank Caddyfile will be</span></span><br><span class="line">	<span class="comment">// used.</span></span><br><span class="line">	<span class="type">DefaultInput</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">Input</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The function that produces a new server type context.</span></span><br><span class="line">	<span class="comment">// This will be called when a new Caddyfile is being</span></span><br><span class="line">	<span class="comment">// loaded, parsed, and executed independently of any</span></span><br><span class="line">	<span class="comment">// startup phases before this one. It's a way to keep</span></span><br><span class="line">	<span class="comment">// each set of server instances separate and to reduce</span></span><br><span class="line">	<span class="comment">// the amount of global state you need.</span></span><br><span class="line">	<span class="type">NewContext</span> <span class="function"><span class="keyword">func</span><span class="params">(inst *Instance)</span></span> <span class="type">Context</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当caddy.ServerType初始化完成之后，会通过caddy.RegisterServerType向CoreDNS进行服务类型为<code>dns</code>的服务注册,并将服务类型注册到如下结构:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serverTypes is a map of registered server types.</span></span><br><span class="line">serverTypes = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]ServerType)</span><br></pre></td></tr></table></figure>
<p>上面介绍的这些都是CoreDNS服务在启动过程中的初始化工作。go on</p>
<p>在<code>Run()</code>中会执行:</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">corefile,</span> err := caddy.LoadCaddyfile(serverType)</span><br></pre></td></tr></table></figure>
<p>该函数的主要作用就是加载<code>Corefile</code>配置文件，并将配置文件的内容解析到如下的结构中用于后续服务的使用:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Input <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Gets the Caddyfile contents</span></span><br><span class="line">	Body() []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gets the path to the origin file</span></span><br><span class="line">	Path() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The type of server this input is intended for</span></span><br><span class="line">	ServerType() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载完成Corefile之后，接下来就开始启动engine了 😋。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span>, err := caddy.<span class="type">Start</span>(<span class="title">corefile</span>)</span></span><br></pre></td></tr></table></figure>
<p>Start函数会等所有需要的服务都LISTEN之后，才会返回，否者会一直block, 具体定义如下所示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(cdyfile Input)</span> <span class="params">(*Instance, error)</span></span> &#123;</span><br><span class="line">	inst := &amp;Instance&#123;serverType: cdyfile.ServerType(), wg: <span class="built_in">new</span>(sync.WaitGroup), Storage: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line">	err := startWithListenerFds(cdyfile, inst, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> inst, err</span><br><span class="line">	&#125;</span><br><span class="line">	signalSuccessToParent()</span><br><span class="line">	<span class="keyword">if</span> pidErr := writePidFile(); pidErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"[ERROR] Could not write pidfile: %v"</span>, pidErr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Execute instantiation events</span></span><br><span class="line">	EmitEvent(InstanceStartupEvent, inst)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inst, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Start函数会返回一个<code>Instance</code>的结构，该结构中保存了一些服务的状态，用于服务的启动。</p>
<p>Instance结构的定义如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">type <span class="type">Instance</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">	<span class="comment">// serverType is the name of the instance's server type</span></span><br><span class="line">	serverType string</span><br><span class="line"></span><br><span class="line">	<span class="comment">// caddyfileInput is the input configuration text used for this process</span></span><br><span class="line">	caddyfileInput <span class="type">Input</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// wg is used to wait for all servers to shut down</span></span><br><span class="line">	wg *sync.<span class="type">WaitGroup</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// context is the context created for this instance,</span></span><br><span class="line">	<span class="comment">// used to coordinate the setting up of the server type</span></span><br><span class="line">	context <span class="type">Context</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// servers is the list of servers with their listeners</span></span><br><span class="line">	servers []<span class="type">ServerListener</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// these callbacks execute when certain events occur</span></span><br><span class="line">	<span class="type">OnFirstStartup</span>  []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> error <span class="comment">// starting, not as part of a restart</span></span><br><span class="line">	<span class="type">OnStartup</span>       []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> error <span class="comment">// starting, even as part of a restart</span></span><br><span class="line">	<span class="type">OnRestart</span>       []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> error <span class="comment">// before restart commences</span></span><br><span class="line">	<span class="type">OnRestartFailed</span> []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> error <span class="comment">// if restart failed</span></span><br><span class="line">	<span class="type">OnShutdown</span>      []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> error <span class="comment">// stopping, even as part of a restart</span></span><br><span class="line">	<span class="type">OnFinalShutdown</span> []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> error <span class="comment">// stopping, not as part of a restart</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// storing values on an instance is preferable to</span></span><br><span class="line">	<span class="comment">// global state because these will get garbage-</span></span><br><span class="line">	<span class="comment">// collected after in-process reloads when the</span></span><br><span class="line">	<span class="comment">// old instances are destroyed; use StorageMu</span></span><br><span class="line">	<span class="comment">// to access this value safely</span></span><br><span class="line">	<span class="type">Storage</span>   <span class="built_in">map</span>[interface&#123;&#125;]interface&#123;&#125;</span><br><span class="line">	<span class="type">StorageMu</span> sync.<span class="type">RWMutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>serverType:表示该Instance被关联到具体哪一个服务类型,在我们这里是<code>dns</code>。</li>
<li>caddyfileInput: 已经被加载的corefile文件的内容。</li>
<li>context: 启动服务使用的一些context内容。</li>
<li><p>servers: 该instance需要启动的服务列表(在我们这里主要是TCP和UDP服务)。</p>
<p>  其它的就是一个plugin注册到服务的启动回调函数(callbacks)，当服务启动的时候，会去根据不同的plugin加载具体的启动callback函数。</p>
</li>
</ul>
<p>好了，让我们继续回到Start函数的定义中, 在该函数中主要调用三个函数分别是:</p>
<ul>
<li>startWithListenerFds: 用于解析Corefile配置文件及校验指令执行的是否正确，并启动CoreDNS服务。</li>
<li>signalSuccessToParent: 向父进程报告服务启动状态。</li>
<li>writePidFile: 将启动服务的进程ID(PID)写入到指定的文件。</li>
</ul>
<p>从上面的解释中即可知道startWithListenerFds是最为核心的函数调用了，接下来直接详细的分析startWithListenerFds函数。在该函数中首先会调用</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">loadServerBlocks</span>(stypeName, cdyfile.<span class="type">Path</span>(), bytes.<span class="type">NewReader</span>(cdyfile.<span class="type">Body</span>()))`</span><br></pre></td></tr></table></figure>
<p>这个函数的主要作用是加载Corefile文件的内容，并解析该文件的内容到<code>ServerBlock</code>结构:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">ServerBlock</span> struct &#123;</span><br><span class="line">	<span class="type">Keys</span>   []string</span><br><span class="line">	<span class="type">Tokens</span> map[string][]<span class="type">Token</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的keys主要用于存储Corefile文件中的Zone相关的数据(比如: server的地址及端口号等)，而Tokens用于存储该server下面的plugin的信息，其中Tokens的key是plugin name, []Token存储的是该plugin在Corefile中的位置，便于后续的解析操作。</p>
<p>之后会调用NewContext对instance的Context进行初始化。然后通过该Context实例分别去调用:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Context</span> <span class="selector-tag">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Called after the Caddyfile is parsed into server</span></span><br><span class="line">	<span class="comment">// blocks but before the directives are executed,</span></span><br><span class="line">	<span class="comment">// this method gives you an opportunity to inspect</span></span><br><span class="line">	<span class="comment">// the server blocks and prepare for the execution</span></span><br><span class="line">	<span class="comment">// of directives. Return the server blocks (which</span></span><br><span class="line">	<span class="comment">// you may modify, if desired) and an error, if any.</span></span><br><span class="line">	<span class="comment">// The first argument is the name or path to the</span></span><br><span class="line">	<span class="comment">// configuration file (Caddyfile).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This function can be a no-op and simply return its</span></span><br><span class="line">	<span class="comment">// input if there is nothing to do here.</span></span><br><span class="line">	<span class="selector-tag">InspectServerBlocks</span>(string, []caddyfile.ServerBlock) ([]caddyfile.ServerBlock, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is what Caddy calls to make server instances.</span></span><br><span class="line">	<span class="comment">// By this time, all directives have been executed and,</span></span><br><span class="line">	<span class="comment">// presumably, the context has enough state to produce</span></span><br><span class="line">	<span class="comment">// server instances for Caddy to start.</span></span><br><span class="line">	<span class="selector-tag">MakeServers</span>() ([]Server, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ValidateAndExecuteDirectives</code>函数中只调用了<code>InspectServerBlocks</code>,这个函数会在解析完Corefile文件之后，执行Corefile中的指令之前会被调用，用于进一步的对serverblock进行检查并进行进一步的参数完善。</p>
<p>等上面的准备工作准备完成之后，会调用<code>executeDirectives</code>去遍历所有的指令<code>directives</code>,如果serverblock中的指令在<code>directives</code>,则设置相应的Controller去执行相关plugin的action动作:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeDirectives</span><span class="params">(inst *Instance, filename <span class="keyword">string</span>, directives []<span class="keyword">string</span>, sblocks []caddyfile.ServerBlock, justValidate <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// a directive for all server blocks before going to the next directive.</span></span><br><span class="line">	<span class="comment">// This is important mainly due to the parsing callbacks (below).</span></span><br><span class="line">	<span class="keyword">for</span> _, dir := <span class="keyword">range</span> directives &#123;</span><br><span class="line">		<span class="keyword">for</span> i, sb := <span class="keyword">range</span> sblocks &#123;</span><br><span class="line">			<span class="keyword">for</span> j, key := <span class="keyword">range</span> sb.Keys &#123;</span><br><span class="line">				<span class="comment">// Execute directive if it is in the server block</span></span><br><span class="line">				<span class="keyword">if</span> tokens, ok := sb.Tokens[dir]; ok &#123;</span><br><span class="line">					controller := &amp;Controller&#123;</span><br><span class="line">						instance:  inst,</span><br><span class="line">						Key:       key,</span><br><span class="line">						Dispenser: caddyfile.NewDispenserTokens(filename, tokens),</span><br><span class="line">						OncePerServerBlock: <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">							<span class="keyword">var</span> err error</span><br><span class="line">							once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">								err = f()</span><br><span class="line">							&#125;)</span><br><span class="line">							<span class="keyword">return</span> err</span><br><span class="line">						&#125;,</span><br><span class="line">						ServerBlockIndex:    i,</span><br><span class="line">						ServerBlockKeyIndex: j,</span><br><span class="line">						ServerBlockKeys:     sb.Keys,</span><br><span class="line">						ServerBlockStorage:  storages[i][dir],</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					setup, err := DirectiveAction(inst.serverType, dir)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					err = setup(controller)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					storages[i][dir] = controller.ServerBlockStorage <span class="comment">// persist for this server block</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>ValidateAndExecuteDirectives</code>函数的进一步对Corefile解析，并通过解析过的各个plugin进行执行之后，Corefile文件中定义的相关的plugin插件基本都已处于准备好的状态。</p>
<p>接下来调用dnsContext的MakeServers方法，用于启动CoreDNS服务，接收外部的请求。下面是MakeServers的函数定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *dnsContext)</span> <span class="title">MakeServers</span><span class="params">()</span> <span class="params">([]caddy.Server, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> .......</span><br><span class="line">	<span class="comment">// we must map (group) each config to a bind address</span></span><br><span class="line">	groups, err := groupConfigsByListenAddr(h.configs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// then we create a server for each group</span></span><br><span class="line">	<span class="keyword">var</span> servers []caddy.Server</span><br><span class="line">	<span class="keyword">for</span> addr, group := <span class="keyword">range</span> groups &#123;</span><br><span class="line">		<span class="comment">// switch on addr</span></span><br><span class="line">		<span class="keyword">switch</span> tr, _ := parse.Transport(addr); tr &#123;</span><br><span class="line">		<span class="keyword">case</span> transport.DNS:</span><br><span class="line">			s, err := NewServer(addr, group)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			servers = <span class="built_in">append</span>(servers, s)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> transport.TLS:</span><br><span class="line">			s, err := NewServerTLS(addr, group)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			servers = <span class="built_in">append</span>(servers, s)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> transport.GRPC:</span><br><span class="line">			s, err := NewServergRPC(addr, group)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			servers = <span class="built_in">append</span>(servers, s)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> transport.HTTPS:</span><br><span class="line">			s, err := NewServerHTTPS(addr, group)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			servers = <span class="built_in">append</span>(servers, s)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> servers, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MakeServers函数中首先会调用:groupConfigsByListenAddr用于将不同server下的配置进行分组。并返回一个map：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupConfigsByListenAddr</span><span class="params">(configs []*Config)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]*Config, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	groups := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]*Config)</span><br><span class="line">	<span class="keyword">for</span> _, conf := <span class="keyword">range</span> configs &#123;</span><br><span class="line">		<span class="keyword">for</span> _, h := <span class="keyword">range</span> conf.ListenHosts &#123;</span><br><span class="line">			addr, err := net.ResolveTCPAddr(<span class="string">"tcp"</span>, net.JoinHostPort(h, conf.Port))</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			addrstr := conf.Transport + <span class="string">"://"</span> + addr.String()</span><br><span class="line">			groups[addrstr] = <span class="built_in">append</span>(groups[addrstr], conf)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> groups, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中返回的map中，key表示的是服务的地址，value表示与该服务相关的配置信息。</p>
<p>之后遍历该map, 然后根据不同的transport去启动相应的服务，当前CoreDNS支持4种类型的transport:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line"><span class="built_in">	DNS </span>  = <span class="string">"dns"</span></span><br><span class="line">	TLS   = <span class="string">"tls"</span></span><br><span class="line">	GRPC  = <span class="string">"grpc"</span></span><br><span class="line">	HTTPS = <span class="string">"https"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>无论是哪一种类型的transport最终都会去执行<code>NewServer</code>函数。<code>NewServer</code>会返回一些CoreDNS server:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ype Server struct &#123;</span><br><span class="line">	Addr string <span class="comment">// Address we listen on</span></span><br><span class="line"></span><br><span class="line">	server [<span class="number">2</span>]*dns<span class="selector-class">.Server</span> <span class="comment">// 0 is a net.Listener, 1 is a net.PacketConn (a *UDPConn) in our case.</span></span><br><span class="line">	m      sync<span class="selector-class">.Mutex</span>     <span class="comment">// protects the servers</span></span><br><span class="line"></span><br><span class="line">	zones        map[string]*Config <span class="comment">// zones keyed by their address</span></span><br><span class="line">	dnsWg        sync<span class="selector-class">.WaitGroup</span>     <span class="comment">// used to wait on outstanding connections</span></span><br><span class="line">	graceTimeout <span class="selector-tag">time</span><span class="selector-class">.Duration</span>      <span class="comment">// the maximum duration of a graceful shutdown</span></span><br><span class="line">	trace        trace<span class="selector-class">.Trace</span>        <span class="comment">// the trace plugin for the server</span></span><br><span class="line">	debug        bool               <span class="comment">// disable recover()</span></span><br><span class="line">	classChaos   bool               <span class="comment">// allow non-INET class queries</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只是make了CoreDNS需要启动的<code>Server</code>结构,但是真正的服务进程到现在这个阶段还没有真正的启动。</p>
<p>接下来的操作是通过下面的这部分代码来对已经注册的各个plugin进行启动操作，也就是在每个plugin会在进行<code>setup</code>的时候，指定相关的回调函数(callback)，也就是上面介绍<code>Instance</code>结构的时候，介绍的哪些回调函数(callback)。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, startupFunc := <span class="keyword">range</span> inst.OnStartup &#123;</span><br><span class="line">		<span class="keyword">err</span> = startupFunc()</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>当所有的plugin需要的准备工作都处理完成之后，就调用<code>startServers</code>来启动CoreDNS服务,<code>startServers</code>函数的定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServers</span><span class="params">(serverList []Server, inst *Instance, restartFds <span class="keyword">map</span>[<span class="keyword">string</span>]restartTriple)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> serverList &#123;</span><br><span class="line">		<span class="keyword">if</span> ln == <span class="literal">nil</span> &#123;</span><br><span class="line">			ln, err = s.Listen()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"Listen: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pc == <span class="literal">nil</span> &#123;</span><br><span class="line">			pc, err = s.ListenPacket()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"ListenPacket: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		inst.servers = <span class="built_in">append</span>(inst.servers, ServerListener&#123;server: s, listener: ln, packet: pc&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> inst.servers &#123;</span><br><span class="line">		inst.wg.Add(<span class="number">2</span>)</span><br><span class="line">		stopWg.Add(<span class="number">2</span>)</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(s Server, ln net.Listener, pc net.PacketConn, inst *Instance)</span></span> &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					inst.wg.Done()</span><br><span class="line">					stopWg.Done()</span><br><span class="line">				&#125;()</span><br><span class="line">				errChan &lt;- s.Serve(ln)</span><br><span class="line">			&#125;()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					inst.wg.Done()</span><br><span class="line">					stopWg.Done()</span><br><span class="line">				&#125;()</span><br><span class="line">				errChan &lt;- s.ServePacket(pc)</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;(s.server, s.listener, s.packet, inst)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Log errors that may be returned from Serve() calls,</span></span><br><span class="line">	<span class="comment">// these errors should only be occurring in the server loop.</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> err := &lt;-errChan:</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> !strings.Contains(err.Error(), <span class="string">"use of closed network connection"</span>) &#123;</span><br><span class="line">						<span class="comment">// this error is normal when closing the listener; see https://github.com/golang/go/issues/4373</span></span><br><span class="line">						log.Println(err)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> &lt;-stopChan:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		stopWg.Wait()</span><br><span class="line">		stopChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>startServers</code>函数中去遍历serverList去分别启动<code>TCP</code>和<code>UDP</code>服务。用于接收外部的DNS请求。</p>
<p>最后,caddy.Wait()主进程进入等待状态，caddy开始处理接收到的请求，这里的每个请求都会发送给<code>core/dnsserver/server.go</code>的ServerDNS处理，这里是DNS的总逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeDNS is the entry point for every request to the address that s</span></span><br><span class="line"><span class="comment">// is bound to. It acts as a multiplexer for the requests zonename as</span></span><br><span class="line"><span class="comment">// defined in the request so that the correct zone</span></span><br><span class="line"><span class="comment">// (configuration and plugin stack) will handle the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ServeDNS</span><span class="params">(ctx context.Context, w dns.ResponseWriter, r *dns.Msg)</span></span> &#123;</span><br><span class="line">	<span class="comment">// The default dns.Mux checks the question section size, but we have our</span></span><br><span class="line">	<span class="comment">// own mux here. Check if we have a question section. If not drop them here.</span></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wrap the response writer in a ScrubWriter so we automatically make the reply fit in the client's buffer.</span></span><br><span class="line">	w = request.NewScrubWriter(r, w)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		l := <span class="built_in">len</span>(q[off:])</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">			b[i] = q[off+i]</span><br><span class="line">			<span class="comment">// normalize the name for the lookup</span></span><br><span class="line">			<span class="keyword">if</span> b[i] &gt;= <span class="string">'A'</span> &amp;&amp; b[i] &lt;= <span class="string">'Z'</span> &#123;</span><br><span class="line">				b[i] |= (<span class="string">'a'</span> - <span class="string">'A'</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> h, ok := s.zones[<span class="keyword">string</span>(b[:l])]; ok &#123;</span><br><span class="line">			<span class="keyword">if</span> r.Question[<span class="number">0</span>].Qtype != dns.TypeDS &#123;</span><br><span class="line">				<span class="keyword">if</span> h.FilterFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">					rcode, _ := h.pluginChain.ServeDNS(ctx, w, r)</span><br><span class="line">					<span class="keyword">if</span> !plugin.ClientWrite(rcode) &#123;</span><br><span class="line">						errorFunc(s.Addr, w, r, rcode)</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// FilterFunc is set, call it to see if we should use this handler.</span></span><br><span class="line">				<span class="comment">// This is given to full query name.</span></span><br><span class="line">				<span class="keyword">if</span> h.FilterFunc(q) &#123;</span><br><span class="line">					rcode, _ := h.pluginChain.ServeDNS(ctx, w, r)</span><br><span class="line">					<span class="keyword">if</span> !plugin.ClientWrite(rcode) &#123;</span><br><span class="line">						errorFunc(s.Addr, w, r, rcode)</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// The type is DS, keep the handler, but keep on searching as maybe we are serving</span></span><br><span class="line">			<span class="comment">// the parent as well and the DS should be routed to it - this will probably *misroute* DS</span></span><br><span class="line">			<span class="comment">// queries to a possibly grand parent, but there is no way for us to know at this point</span></span><br><span class="line">			<span class="comment">// if there is an actually delegation from grandparent -&gt; parent -&gt; zone.</span></span><br><span class="line">			<span class="comment">// In all fairness: direct DS queries should not be needed.</span></span><br><span class="line">			dshandler = h</span><br><span class="line">		&#125;</span><br><span class="line">		off, end = dns.NextLabel(q, off)</span><br><span class="line">		<span class="keyword">if</span> end &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r.Question[<span class="number">0</span>].Qtype == dns.TypeDS &amp;&amp; dshandler != <span class="literal">nil</span> &amp;&amp; dshandler.pluginChain != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// DS request, and we found a zone, use the handler for the query.</span></span><br><span class="line">		rcode, _ := dshandler.pluginChain.ServeDNS(ctx, w, r)</span><br><span class="line">		<span class="keyword">if</span> !plugin.ClientWrite(rcode) &#123;</span><br><span class="line">			errorFunc(s.Addr, w, r, rcode)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wildcard match, if we have found nothing try the root zone as a last resort.</span></span><br><span class="line">	<span class="keyword">if</span> h, ok := s.zones[<span class="string">"."</span>]; ok &amp;&amp; h.pluginChain != <span class="literal">nil</span> &#123;</span><br><span class="line">		rcode, _ := h.pluginChain.ServeDNS(ctx, w, r)</span><br><span class="line">		<span class="keyword">if</span> !plugin.ClientWrite(rcode) &#123;</span><br><span class="line">			errorFunc(s.Addr, w, r, rcode)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历dns.NextLabel(dns)，找到匹配的Zone,如果都不匹配,则尝试默认的Zone(“.”)</li>
<li>调动zone.pluginChain.ServerDNS()进行处理，pluginChain是一个链，链的顺顺序是<code>core/dnsserver/zdirectives.go</code>中定义的，按定义的顺序依次执行。(上面已经提到过了：）)</li>
</ul>
<p>注意:每一个插件都需要实现如果这个Interface:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Handler<span class="built_in"> interface </span>&#123;</span><br><span class="line">		ServeDNS(context.Context, dns.ResponseWriter, <span class="number">*d</span>ns.Msg) (int, error)</span><br><span class="line">		Name() string</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>ServeDNS</code>是插件实现的核心逻辑，<code>Name()</code>是插件的名称。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这样CoreDNS整体的一个架构流程就已经分析完了，说CoreDNS服务有什么新的亮点其实也没亮点，主要就依赖于caddy的插件化方案吧，但是现在有很多middleware的web server应该都能满足这个需求，哈哈。好了，本篇文章只是分析了CoreDNS的整体结构，但没有对其内部的各类插件进行细化的分析，例如: kubernetes, forward, health等。关于CoreDNS的内置插件，接下来可能会有篇文章来针对kubernetes插件进行分析：）</p>
</div><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/dns/">dns</a><a href="/tags/coredns/">coredns</a><a href="/tags/network/">network</a></div><div class="post-nav"><a class="next" href="/2019/08/22/dns/">A DNS Refresher</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '86d1945e3a9358946043',
  clientSecret: '304f48ee3394ae5dab75d19a966506e170d850f6',
  repo: 'xigang.github.io',
  owner: 'xigang',
  admin: ['xigang'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://github.com/xigang"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etcd/">etcd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubernetes/">kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/microservices/">microservices</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志监控/">日志监控</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/coredns/" style="font-size: 15px;">coredns</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/kapacitor/" style="font-size: 15px;">kapacitor</a> <a href="/tags/alertmanager/" style="font-size: 15px;">alertmanager</a> <a href="/tags/bosun/" style="font-size: 15px;">bosun</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/cgroup/" style="font-size: 15px;">cgroup</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/etcd/" style="font-size: 15px;">etcd</a> <a href="/tags/dns/" style="font-size: 15px;">dns</a> <a href="/tags/prometheus/" style="font-size: 15px;">prometheus</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/microservices/" style="font-size: 15px;">microservices</a> <a href="/tags/kubeflow/" style="font-size: 15px;">kubeflow</a> <a href="/tags/scheduler/" style="font-size: 15px;">scheduler</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/kube-dns/" style="font-size: 15px;">kube-dns</a> <a href="/tags/ipvs/" style="font-size: 15px;">ipvs</a> <a href="/tags/iptables/" style="font-size: 15px;">iptables</a> <a href="/tags/netfilter/" style="font-size: 15px;">netfilter</a> <a href="/tags/mxnet/" style="font-size: 15px;">mxnet</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/coredns/">CoreDNS源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/dns/">A DNS Refresher</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/kube-proxy-source-code/">Kube-Proxy  IPVS模式源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/kubernetes-service/">浅谈Kubernetes Service负载均衡实现机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/cgroupv2/">CGROUPS VERSION 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/11/bosun/">Prometheus基于bosun框架进行告警</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/09/container-resource-metrics/">A Deep Dive Into Kubernetes Metrics - Container Resource Metrics</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/metrics-servere/">Kubernetes Metrics-Server介绍及源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/gang-scheduler/">适合AI场景的调度器 - Gang-Schedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/30/tensorflow/">Tensorflow结合kubeflow进行分布式训练</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://gogap.cn/" title="gogap" target="_blank">gogap</a><ul></ul><a href="http://www.0x7c00.net/" title="31744" target="_blank">31744</a><ul></ul><a href="https://www.opsdev.cn/" title="360opsdev" target="_blank">360opsdev</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">xigang's home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>