<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Kube-Proxy  IPVS模式源码分析 | xigang's home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kube-Proxy  IPVS模式源码分析</h1><a id="logo" href="/.">xigang's home</a><p class="description">Do it right or don't do it at all</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kube-Proxy  IPVS模式源码分析</h1><div class="post-meta">Jul 28, 2019<span> | </span><span class="category"><a href="/categories/kubernetes/">kubernetes</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>kube-proxy当前支持三种方式实现负载均衡，分别是: userspace, Iptables, IPVS. 但前两者随着Service的数量增长，存在性能的瓶颈，在生产环境是不能接受的。所以本篇文章主要对IPVS模式进行源码分析。</p>
<p>代码版本: release-1.15</p>
<a id="more"></a>
<h3 id="kube-proxy-整体逻辑结构"><a href="#kube-proxy-整体逻辑结构" class="headerlink" title="kube-proxy 整体逻辑结构"></a>kube-proxy 整体逻辑结构</h3><div align="left"><br><img src="http://p4.qhimg.com/t01145ecd4b17bae621.png" width="1000" height="700" alt="kube-proxy"><br></div>

<p>这张时序图描述了kube-proxy的整体逻辑结构，由于kub-proxy组件和其它的<code>kube-*</code> 组件一样都是使用<a href="https://github.com/spf13/pflag">pflag</a>和<a href="https://github.com/spf13/cobra">cobra</a>库去构建命令行应用程序。所以先简单介绍下该包的基本使用方式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123;</span><br><span class="line">  <span class="attribute">command </span>:= &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">"echo [string to echo]"</span>,</span><br><span class="line">    Short: <span class="string">"Echo anything to the screen"</span>,</span><br><span class="line">    Long: `echo is for echoing anything back.Echo works a lot like print, except it has a child command.`,</span><br><span class="line">    Args: cobra.<span class="built_in">MinimumNArgs</span>(1),</span><br><span class="line">    Run: <span class="built_in">func</span>(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.<span class="built_in">Println</span>(<span class="string">"Print: "</span> + strings.Join(args, <span class="string">" "</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">command</span><span class="selector-class">.Execute</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码就是使用<code>cobra</code>包的一个最简单的例子，首先初始化Command结构，其中该结构中的<code>Run</code>就是最终要执行的真正逻辑。当初始化完成Command之后，通过<code>commnad.Execute</code>去启动应用程序。</p>
<p>现在看上面的图就能比较直观的理解程序的启动机制了，这张图的整体过程就是对Commnad结构中的<code>Run</code>进行核心逻辑实现。也就是说<code>kube-proxy核心逻辑入口就是从这里开始(Command.Run)</code>。😋</p>
<p>在<code>Command.Run</code>中主要做了如下几件事,看下面的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the specified ProxyServer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(o.errCh)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">	proxyServer, err := NewProxyServer(o)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> o.CleanupAndExit &#123;</span><br><span class="line">		<span class="keyword">return</span> proxyServer.CleanupAndExit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.proxyServer = proxyServer</span><br><span class="line">	<span class="keyword">return</span> o.runLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.对<code>ProxyServer</code>实例进行初始化。<br>2.如果在启动kube-proxy服务时，<code>CleanupAndExit</code>参数设置为<code>true</code>,则会将<code>userspace</code>, <code>iptables</code>, <code>ipvs</code>三种模式之前设置的所有规则清除掉，然后直接退出。<br>3.如果在启动kube-proxy服务时，<code>CleanupAndExit</code>参数设置为<code>flase</code>,则会调用<code>runLoop</code>来启动<code>ProxyServer</code>服务。</p>
<p>首先先来看看<code>ProxyServer</code>的结构定义:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">ProxyServer</span> struct &#123;</span><br><span class="line">	<span class="type">Client</span>                 clientset.<span class="type">Interface</span> </span><br><span class="line">	<span class="type">EventClient</span>            v1core.<span class="type">EventsGetter</span></span><br><span class="line">	<span class="type">IptInterface</span>           utiliptables.<span class="type">Interface</span></span><br><span class="line">	<span class="type">IpvsInterface</span>          utilipvs.<span class="type">Interface</span></span><br><span class="line">	<span class="type">IpsetInterface</span>         utilipset.<span class="type">Interface</span></span><br><span class="line">	execer                 exec.<span class="type">Interface</span></span><br><span class="line">	<span class="type">Proxier</span>                proxy.<span class="type">ProxyProvider</span></span><br><span class="line">	<span class="type">Broadcaster</span>            record.<span class="type">EventBroadcaster</span></span><br><span class="line">	<span class="type">Recorder</span>               record.<span class="type">EventRecorder</span></span><br><span class="line">	<span class="type">ConntrackConfiguration</span> kubeproxyconfig.<span class="type">KubeProxyConntrackConfiguration</span></span><br><span class="line">	<span class="type">Conntracker</span>            <span class="type">Conntracker</span> // if nil, ignored</span><br><span class="line">	<span class="type">ProxyMode</span>              string</span><br><span class="line">	<span class="type">NodeRef</span>                *v1.<span class="type">ObjectReference</span></span><br><span class="line">	<span class="type">CleanupIPVS</span>            bool</span><br><span class="line">	<span class="type">MetricsBindAddress</span>     string</span><br><span class="line">	<span class="type">EnableProfiling</span>        bool</span><br><span class="line">	<span class="type">OOMScoreAdj</span>            *int32</span><br><span class="line">	<span class="type">ConfigSyncPeriod</span>       time.<span class="type">Duration</span></span><br><span class="line">	<span class="type">HealthzServer</span>          *healthcheck.<span class="type">HealthzServer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ProxyServer</code>结构中:</p>
<p>包含了与<code>kube-apiserver</code>通信的<code>Client</code>。</p>
<p>操作<code>Iptables</code>的<code>IptInterface</code>:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Interface interface &#123;</span><br><span class="line">	<span class="comment">// GetVersion returns the "X.Y.Z" version string for iptables.</span></span><br><span class="line">	GetVersion() (string, error)</span><br><span class="line">	<span class="comment">// EnsureChain checks if the specified chain exists and, if not, creates it.  If the chain existed, return true.</span></span><br><span class="line">	EnsureChain(<span class="keyword">table</span> <span class="keyword">Table</span>, chain <span class="comment">Chain) (bool, error)</span></span><br><span class="line">	<span class="comment">// FlushChain clears the specified chain.  If the chain did not exist, return error.</span></span><br><span class="line">	FlushChain(<span class="keyword">table</span> <span class="keyword">Table</span>, chain <span class="comment">Chain) error</span></span><br><span class="line">	<span class="comment">// DeleteChain deletes the specified chain.  If the chain did not exist, return error.</span></span><br><span class="line">	DeleteChain(<span class="keyword">table</span> <span class="keyword">Table</span>, chain <span class="comment">Chain) error</span></span><br><span class="line">	<span class="comment">// EnsureRule checks if the specified rule is present and, if not, creates it.  If the rule existed, return true.</span></span><br><span class="line">	EnsureRule(position RulePosition, <span class="keyword">table</span> <span class="keyword">Table</span>, chain <span class="comment">Chain, args ...string) (bool, error)</span></span><br><span class="line">	<span class="comment">// DeleteRule checks if the specified rule is present and, if so, deletes it.</span></span><br><span class="line">	DeleteRule(<span class="keyword">table</span> <span class="keyword">Table</span>, chain <span class="comment">Chain, args ...string) error</span></span><br><span class="line">	<span class="comment">// IsIpv6 returns true if this is managing ipv6 tables</span></span><br><span class="line">	IsIpv6() bool</span><br><span class="line">	<span class="comment">// SaveInto calls `iptables-save` for table and stores result in a given buffer.</span></span><br><span class="line">	SaveInto(<span class="keyword">table</span> <span class="keyword">Table</span>, buffer <span class="comment">*bytes.Buffer) error</span></span><br><span class="line">	<span class="comment">// Restore runs `iptables-restore` passing data through []byte.</span></span><br><span class="line">	<span class="comment">// table is the Table to restore</span></span><br><span class="line">	<span class="comment">// data should be formatted like the output of SaveInto()</span></span><br><span class="line">	<span class="comment">// flush sets the presence of the "--noflush" flag. see: FlushFlag</span></span><br><span class="line">	<span class="comment">// counters sets the "--counters" flag. see: RestoreCountersFlag</span></span><br><span class="line">	Restore(<span class="keyword">table</span> <span class="keyword">Table</span>, data <span class="comment">[]byte, flush FlushFlag, counters RestoreCountersFlag) error</span></span><br><span class="line">	<span class="comment">// RestoreAll is the same as Restore except that no table is specified.</span></span><br><span class="line">	RestoreAll(data []byte, flush FlushFlag, counters RestoreCountersFlag) error</span><br><span class="line">	<span class="comment">// AddReloadFunc adds a function to call on iptables reload</span></span><br><span class="line">	AddReloadFunc(reloadFunc func())</span><br><span class="line">	<span class="comment">// Destroy cleans up resources used by the Interface</span></span><br><span class="line">	Destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作<code>IPVS</code>的<code>IpvsInterface</code>:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Interface</span> interface &#123;</span><br><span class="line">	// <span class="type">Flush</span> clears all virtual servers in system. return occurred error immediately.</span><br><span class="line">	<span class="type">Flush</span>() error</span><br><span class="line">	// <span class="type">AddVirtualServer</span> creates the specified virtual server.</span><br><span class="line">	<span class="type">AddVirtualServer</span>(*<span class="type">VirtualServer</span>) error</span><br><span class="line">	// <span class="type">UpdateVirtualServer</span> updates an already existing virtual server.  <span class="type">If</span> the virtual server does not exist, return error.</span><br><span class="line">	<span class="type">UpdateVirtualServer</span>(*<span class="type">VirtualServer</span>) error</span><br><span class="line">	// <span class="type">DeleteVirtualServer</span> deletes the specified virtual server.  <span class="type">If</span> the virtual server does not exist, return error.</span><br><span class="line">	<span class="type">DeleteVirtualServer</span>(*<span class="type">VirtualServer</span>) error</span><br><span class="line">	// <span class="type">Given</span> a partial virtual server, <span class="type">GetVirtualServer</span> will return the specified virtual server information in the system.</span><br><span class="line">	<span class="type">GetVirtualServer</span>(*<span class="type">VirtualServer</span>) (*<span class="type">VirtualServer</span>, error)</span><br><span class="line">	// <span class="type">GetVirtualServers</span> lists all virtual servers in the system.</span><br><span class="line">	<span class="type">GetVirtualServers</span>() ([]*<span class="type">VirtualServer</span>, error)</span><br><span class="line">	// <span class="type">AddRealServer</span> creates the specified real server for the specified virtual server.</span><br><span class="line">	<span class="type">AddRealServer</span>(*<span class="type">VirtualServer</span>, *<span class="type">RealServer</span>) error</span><br><span class="line">	// <span class="type">GetRealServers</span> returns all real servers for the specified virtual server.</span><br><span class="line">	<span class="type">GetRealServers</span>(*<span class="type">VirtualServer</span>) ([]*<span class="type">RealServer</span>, error)</span><br><span class="line">	// <span class="type">DeleteRealServer</span> deletes the specified real server from the specified virtual server.</span><br><span class="line">	<span class="type">DeleteRealServer</span>(*<span class="type">VirtualServer</span>, *<span class="type">RealServer</span>) error</span><br><span class="line">	// <span class="type">UpdateRealServer</span> updates the specified real server from the specified virtual server.</span><br><span class="line">	<span class="type">UpdateRealServer</span>(*<span class="type">VirtualServer</span>, *<span class="type">RealServer</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作<code>IpSet</code>的<code>IpsetInterface</code>:</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface is an injectable interface for running ipset commands.  Implementations must be goroutine-safe.</span></span><br><span class="line"><span class="built_in">type</span> Interface interface &#123;</span><br><span class="line">	<span class="comment">// FlushSet deletes all entries from a named set.</span></span><br><span class="line">	FlushSet(set <span class="keyword">string</span>) <span class="built_in">error</span></span><br><span class="line">	<span class="comment">// DestroySet deletes a named set.</span></span><br><span class="line">	DestroySet(set <span class="keyword">string</span>) <span class="built_in">error</span></span><br><span class="line">	<span class="comment">// DestroyAllSets deletes all sets.</span></span><br><span class="line">	DestroyAllSets() <span class="built_in">error</span></span><br><span class="line">	<span class="comment">// CreateSet creates a new set.  It will ignore error when the set already exists if ignoreExistErr=true.</span></span><br><span class="line">	CreateSet(set *IPSet, ignoreExistErr <span class="keyword">bool</span>) <span class="built_in">error</span></span><br><span class="line">	<span class="comment">// AddEntry adds a new entry to the named set.  It will ignore error when the entry already exists if ignoreExistErr=true.</span></span><br><span class="line">	AddEntry(entry <span class="keyword">string</span>, set *IPSet, ignoreExistErr <span class="keyword">bool</span>) <span class="built_in">error</span></span><br><span class="line">	<span class="comment">// DelEntry deletes one entry from the named set</span></span><br><span class="line">	DelEntry(entry <span class="keyword">string</span>, set <span class="keyword">string</span>) <span class="built_in">error</span></span><br><span class="line">	<span class="comment">// Test test if an entry exists in the named set</span></span><br><span class="line">	TestEntry(entry <span class="keyword">string</span>, set <span class="keyword">string</span>) (<span class="keyword">bool</span>, <span class="built_in">error</span>)</span><br><span class="line">	<span class="comment">// ListEntries lists all the entries from a named set</span></span><br><span class="line">	ListEntries(set <span class="keyword">string</span>) ([]<span class="keyword">string</span>, <span class="built_in">error</span>)</span><br><span class="line">	<span class="comment">// ListSets list all set names from kernel</span></span><br><span class="line">	ListSets() ([]<span class="keyword">string</span>, <span class="built_in">error</span>)</span><br><span class="line">	<span class="comment">// GetVersion returns the "X.Y" version string for ipset.</span></span><br><span class="line">	GetVersion() (<span class="keyword">string</span>, <span class="built_in">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及通过<code>ProxyMode</code>参数获取基于<code>userspace</code>, <code>iptables</code>, <code>ipvs</code>三种方式中的哪种使用的<code>Proxier</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProxyProvider is the interface provided by proxier implementations.</span></span><br><span class="line">type ProxyProvider interface &#123;</span><br><span class="line">	config.EndpointsHandler</span><br><span class="line">	config.ServiceHandler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sync immediately synchronizes the ProxyProvider's current state to proxy rules.</span></span><br><span class="line">	Sync()</span><br><span class="line">	<span class="comment">// SyncLoop runs periodic work.</span></span><br><span class="line">	<span class="comment">// This is expected to run as a goroutine or as the main loop of the app.</span></span><br><span class="line">	<span class="comment">// It does not return.</span></span><br><span class="line">	SyncLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来重点介绍基于<code>ipvs</code>模式实现的<code>Proxier</code>, 在<code>ipvs</code>模式下<code>Proxier</code>结构的定义:</p>
<p>注意:由于<code>Proxier</code>定义的内容太多,我这里把接下来介绍的内容保留，其它不准备介绍的内容删除掉，省的占用太多的篇幅。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type Proxier struct &#123;</span><br><span class="line">	endpointsChanges *proxy.EndpointChangeTracker</span><br><span class="line">	serviceChanges   *proxy.ServiceChangeTracker</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	serviceMap   proxy.ServiceMap</span><br><span class="line">	endpointsMap proxy.EndpointsMap</span><br><span class="line">	portsMap     map[utilproxy.LocalPort]utilproxy.Closeable</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	syncRunner      *async<span class="selector-class">.BoundedFrequencyRunner</span> <span class="comment">// governs calls to syncProxyRules</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	iptables       utiliptables.Interface</span><br><span class="line">	ipvs           utilipvs.Interface</span><br><span class="line">	ipset          utilipset.Interface</span><br><span class="line">	exec           utilexec.Interface</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	ipvsScheduler  string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Proxier</code>结构中，先介绍下<code>async.BoundedFrequencyRunner</code>,其它的在介绍<code>ProxyServer.Run</code>的时候介绍:</p>
<p><code>BoundedFrequencyRunner</code>的定义结构如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type BoundedFrequencyRunner struct &#123;</span><br><span class="line">	name        string        <span class="comment">// the name of this instance</span></span><br><span class="line">	minInterval <span class="selector-tag">time</span><span class="selector-class">.Duration</span> <span class="comment">// the min time between runs, modulo bursts</span></span><br><span class="line">	maxInterval <span class="selector-tag">time</span><span class="selector-class">.Duration</span> <span class="comment">// the max time between runs</span></span><br><span class="line"></span><br><span class="line">	run chan struct&#123;&#125; <span class="comment">// try an async run</span></span><br><span class="line"></span><br><span class="line">	mu      sync<span class="selector-class">.Mutex</span>  <span class="comment">// guards runs of fn and all mutations</span></span><br><span class="line">	fn      func()      <span class="comment">// function to run</span></span><br><span class="line">	lastRun <span class="selector-tag">time</span><span class="selector-class">.Time</span>   <span class="comment">// time of last run</span></span><br><span class="line">	timer   timer       <span class="comment">// timer for deferred runs</span></span><br><span class="line">	limiter rateLimiter <span class="comment">// rate limiter for on-demand runs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BoundedFrequencyRunner</code>结构中的<code>run</code>会异步的去定期的执行任务<code>fn</code>，比如定期的执行<code>proxier.syncProxyRules</code>去创建或者更新<code>VirtuaServer</code>和<code>RealServer</code>并将<code>VirtualServer</code>的VIP绑定到dummy interface(kube-ipvs0)。</p>
<p>下面是在<code>NewProxier</code>方法中初始化<code>BoundedFrequencyRunner</code>对象的示例:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxier<span class="selector-class">.syncRunner</span> = async.NewBoundedFrequencyRunner(</span><br><span class="line">    <span class="string">"sync-runner"</span>, proxier<span class="selector-class">.syncProxyRules</span>, minSyncPeriod, syncPeriod, burstSyncs)</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<ul>
<li>minSyncPeriod: 规则最小的更新时间</li>
<li>syncPeriod: 规则最大更新时间</li>
<li>proxier.syncProxyRules: 同步规则的实现函数(也是kube-proxy基于ipvs同步规则的核心实现)</li>
</ul>
<p>接下来介绍下<code>ProxyServer.Run</code>的逻辑实现部分:</p>
<h3 id="ProxyServer启动流程"><a href="#ProxyServer启动流程" class="headerlink" title="ProxyServer启动流程"></a>ProxyServer启动流程</h3><div align="left"><br><img src="http://p5.qhimg.com/t013c681c83e3884839.png" width="1000" height="600" alt="kube-proxy"><br></div>

<p>上面这张图是<code>ProxyServer</code>启动的整个流程图。在启动过程中，主要做了下面这几件事儿:</p>
<p>1.启动健康检查服务<code>HealthzServer</code>.<br>2.启动暴露监控指标的<code>MetricsServer</code>.<br>3.如果需要调整系统的conntrack相关参数,则对系统的conntrack进行参数调整.<br>4.创建一个<code>informerFactory</code>实例，后面去通过<code>informerFactory</code>获取kubernetes的各类资源数据.<br>5.创建一个<code>ServiceConfig</code>实例，这个实例主要作用是实时的<code>WATCH</code> kubernetes Service资源的变化，并加入队列中，用于后续对变化的Service进行规则同步。<br>6.注册<code>servier event hander</code>到<code>Proxier</code>.<br>7.启动serviceConfig.</p>
<p>接下来详细的介绍下[4-7]这几步的流程:</p>
<p><code>ServiceConfig</code>的结构定义如下:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">ServiceConfig</span> struct &#123;</span><br><span class="line">	listerSynced  cache.<span class="type">InformerSynced</span></span><br><span class="line">	eventHandlers []<span class="type">ServiceHandler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServiceHandler</code>的结构定义如下:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">ServiceHandler </span><span class="keyword">interface</span> &#123;</span><br><span class="line">	// OnServiceAdd <span class="keyword">is</span> called whenever creation <span class="keyword">of</span> <span class="keyword">new</span> service object</span><br><span class="line">	// <span class="keyword">is</span> observed.</span><br><span class="line">	OnServiceAdd(service *v1.Service)</span><br><span class="line">	// OnServiceUpdate <span class="keyword">is</span> called whenever modification <span class="keyword">of</span> an existing</span><br><span class="line">	// service object <span class="keyword">is</span> observed.</span><br><span class="line">	OnServiceUpdate(oldService, service *v1.Service)</span><br><span class="line">	// OnServiceDelete <span class="keyword">is</span> called whenever deletion <span class="keyword">of</span> an existing service</span><br><span class="line">	// object <span class="keyword">is</span> observed.</span><br><span class="line">	OnServiceDelete(service *v1.Service)</span><br><span class="line">	// OnServiceSynced <span class="keyword">is</span> called once <span class="keyword">all</span> the initial even handlers were</span><br><span class="line">	// called <span class="keyword">and</span> the state <span class="keyword">is</span> fully propagated to local cache.</span><br><span class="line">	OnServiceSynced()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>ServiceConfig</code>实例对象的具体实现如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">NewServiceConfig</span>(<span class="selector-tag">serviceInformer</span> <span class="selector-tag">coreinformers</span><span class="selector-class">.ServiceInformer</span>, <span class="selector-tag">resyncPeriod</span> <span class="selector-tag">time</span><span class="selector-class">.Duration</span>) *<span class="selector-tag">ServiceConfig</span> &#123;</span><br><span class="line">	<span class="attribute">result </span>:= &amp;ServiceConfig&#123;</span><br><span class="line">		listerSynced: serviceInformer.<span class="built_in">Informer</span>().HasSynced,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">serviceInformer</span><span class="selector-class">.Informer</span>()<span class="selector-class">.AddEventHandlerWithResyncPeriod</span>(</span><br><span class="line">		<span class="selector-tag">cache</span><span class="selector-class">.ResourceEventHandlerFuncs</span>&#123;</span><br><span class="line">			<span class="attribute">AddFunc</span>:    result.handleAddService,</span><br><span class="line">			UpdateFunc: result.handleUpdateService,</span><br><span class="line">			DeleteFunc: result.handleDeleteService,</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="selector-tag">resyncPeriod</span>,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">return</span> <span class="selector-tag">result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先通过执行<code>serviceInformer.Informer().HasSynced</code>来将kubernetes下的所有Service资源同步到缓存<code>listerSynced</code>中。</li>
<li>其次为<code>AddEventHandlerWithResyncPeriod</code>添加针对<code>Service</code>对象，添加，更新，删除的事件触发函数。当<code>Service</code>有相应的触发动作，就会调用相应的函数:</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">handleAddService</span></span><br><span class="line"><span class="attribute">handleUpdateService</span></span><br><span class="line"><span class="attribute">handleDeleteService</span></span><br></pre></td></tr></table></figure>
<p>我们看看<code>handleAddService</code>触发函数的实现逻辑，具体代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceConfig)</span> <span class="title">handleAddService</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	service, ok := obj.(*v1.Service)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"unexpected object type: %v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.eventHandlers &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Info(<span class="string">"Calling handler.OnServiceAdd"</span>)</span><br><span class="line">		c.eventHandlers[i].OnServiceAdd(service)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当watch到kubernetes集群中有新的<code>Service</code>被创建之后，会触发<code>handleAddService</code>函数，并在该函数中遍历<code>eventHandlers</code>分别去调用<code>OnServiceAdd</code>来对<code>proxier</code>结构中的<code>serviceChanages</code>进行更新并去同步相应的规则。</p>
<p><code>OnServiceAdd</code>的具体实现逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnServiceAdd is called whenever creation of new service object is observed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">OnServiceAdd</span><span class="params">(service *v1.Service)</span></span> &#123;</span><br><span class="line">	proxier.OnServiceUpdate(<span class="literal">nil</span>, service)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OnServiceUpdate is called whenever modification of an existing service object is observed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">OnServiceUpdate</span><span class="params">(oldService, service *v1.Service)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> proxier.serviceChanges.Update(oldService, service) &amp;&amp; proxier.isInitialized() &#123;</span><br><span class="line">		proxier.syncRunner.Run()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServiceChangeTracker</code>的结构定义如下:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ServiceChangeTracker carries state about uncommitted <span class="keyword">changes</span> <span class="keyword">to</span> <span class="keyword">an</span> arbitrary <span class="keyword">number</span> of</span><br><span class="line">// Services, keyed by their namespace <span class="built_in">and</span> name.</span><br><span class="line"><span class="built_in">type</span> ServiceChangeTracker struct &#123;</span><br><span class="line">	// lock protects <span class="built_in">items</span>.</span><br><span class="line">	lock <span class="keyword">sync</span>.Mutex</span><br><span class="line">	// <span class="built_in">items</span> maps <span class="keyword">a</span> service <span class="keyword">to</span> its serviceChange.</span><br><span class="line">	<span class="built_in">items</span> <span class="keyword">map</span>[types.NamespacedName]*serviceChange</span><br><span class="line">	// makeServiceInfo allows proxier <span class="keyword">to</span> inject customized information when processing service.</span><br><span class="line">	makeServiceInfo makeServicePortFunc</span><br><span class="line">	// isIPv6Mode indicates <span class="keyword">if</span> <span class="keyword">change</span> tracker <span class="keyword">is</span> under IPv6/IPv4 <span class="keyword">mode</span>. Nil means not applicable.</span><br><span class="line">	isIPv6Mode *bool</span><br><span class="line">	recorder   record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>serviceChanage</code>的结构定义如下:</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// serviceChange contains <span class="literal">all</span> changes <span class="keyword">to</span> services that happened since proxy rules were synced.  For a single object,</span><br><span class="line">// changes are accumulated, i.e. previous is <span class="keyword">state</span> <span class="keyword">from</span> before applying the changes,</span><br><span class="line">// current is <span class="keyword">state</span> after applying <span class="literal">all</span> of the changes.</span><br><span class="line">type serviceChange struct &#123;</span><br><span class="line">	previous ServiceMap</span><br><span class="line">	current  ServiceMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里在回过头来看上面的基于IPVS实现的<code>Proxier</code>的整体流程就完全通了，<code>ProxyServer.Run</code>函数在启动时，通过kubernetes <code>LIST/WATCH</code>机制去实时的感知kubernetes集群<code>Service</code>资源的变化，然后不断的在更新<code>Proxier</code>结构中的<code>ServiceChanges</code>，然后将变化的<code>Service</code>保存在<code>ServiceChanges</code>结构中的<code>ServiceMap</code>中，给后续的<code>async.BoundedFrequencyRunner</code>去执行同步规则函数<code>syncProxyRules</code>来使用。</p>
<p>8.<code>endpointConfig</code>的实现机制和<code>serviceConfig</code>的机制完全一样，这里就不在详细的介绍了。<br>9.上面做的所有预处理工作，会在<code>informerFactory.Start</code>这步生效。<br>10.<code>birthCry</code>的作用就是通过<code>event</code>的方式通知kubernetes, kube-proxy这边的所有准备工作都处理好了，我要启动了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (s *ProxyServer) birthCry() &#123;</span><br><span class="line">	s<span class="selector-class">.Recorder</span><span class="selector-class">.Eventf</span>(s<span class="selector-class">.NodeRef</span>, api<span class="selector-class">.EventTypeNormal</span>, <span class="string">"Starting"</span>, <span class="string">"Starting kube-proxy."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11.最终通过<code>SyncLoop</code>启动kube-proxy服务，并立刻执行<code>syncProxyRules</code>先来一遍同步在说.之后便会通过异步的方式定期的去同步<code>IPVS</code>, <code>Iptables</code>, <code>Ipset</code>的规则通过<code>syncProxyRules</code>函数:</p>
<p>而<code>syncProxyRules</code>函数是kube-proxy实现的核心。主体逻辑是遍历<code>ServiceMap</code>并遍历<code>ServiceMap</code>下的<code>endpointsMap</code>及创建的<code>Service</code>类型(如: CLusterIP, Loadbalancer, NodePort)去分别创建相应的<code>IPVS</code>规则。</p>
<p><code>syncProxyRules</code>的函数实现定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">syncProxyRules</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build IPVS rules for each service.</span></span><br><span class="line">	<span class="keyword">for</span> svcName, svc := <span class="keyword">range</span> proxier.serviceMap &#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Handle traffic that loops back to the originator with SNAT.</span></span><br><span class="line">		<span class="keyword">for</span> _, e := <span class="keyword">range</span> proxier.endpointsMap[svcName] &#123;</span><br><span class="line">			<span class="comment">//....</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Capture the clusterIP.</span></span><br><span class="line">		<span class="comment">// ipset call</span></span><br><span class="line">		entry := &amp;utilipset.Entry&#123;</span><br><span class="line">			IP:       svcInfo.ClusterIP().String(),</span><br><span class="line">			Port:     svcInfo.Port(),</span><br><span class="line">			Protocol: protocol,</span><br><span class="line">			SetType:  utilipset.HashIPPort,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// add service Cluster IP:Port to kubeServiceAccess ip set for the purpose of solving hairpin.</span></span><br><span class="line">		<span class="comment">// proxier.kubeServiceAccessSet.activeEntries.Insert(entry.String())</span></span><br><span class="line">		<span class="keyword">if</span> valid := proxier.ipsetList[kubeClusterIPSet].validateEntry(entry); !valid &#123;</span><br><span class="line">			klog.Errorf(<span class="string">"%s"</span>, fmt.Sprintf(EntryInvalidErr, entry, proxier.ipsetList[kubeClusterIPSet].Name))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		proxier.ipsetList[kubeClusterIPSet].activeEntries.Insert(entry.String())</span><br><span class="line">		<span class="comment">// ipvs call</span></span><br><span class="line">		serv := &amp;utilipvs.VirtualServer&#123;</span><br><span class="line">			Address:   svcInfo.ClusterIP(),</span><br><span class="line">			Port:      <span class="keyword">uint16</span>(svcInfo.Port()),</span><br><span class="line">			Protocol:  <span class="keyword">string</span>(svcInfo.Protocol()),</span><br><span class="line">			Scheduler: proxier.ipvsScheduler,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Set session affinity flag and timeout for IPVS service</span></span><br><span class="line">		<span class="keyword">if</span> svcInfo.SessionAffinityType() == v1.ServiceAffinityClientIP &#123;</span><br><span class="line">			serv.Flags |= utilipvs.FlagPersistent</span><br><span class="line">			serv.Timeout = <span class="keyword">uint32</span>(svcInfo.StickyMaxAgeSeconds())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// We need to bind ClusterIP to dummy interface, so set `bindAddr` parameter to `true` in syncService()</span></span><br><span class="line">		<span class="keyword">if</span> err := proxier.syncService(svcNameString, serv, <span class="literal">true</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			activeIPVSServices[serv.String()] = <span class="literal">true</span></span><br><span class="line">			activeBindAddrs[serv.Address.String()] = <span class="literal">true</span></span><br><span class="line">			<span class="comment">// ExternalTrafficPolicy only works for NodePort and external LB traffic, does not affect ClusterIP</span></span><br><span class="line">			<span class="comment">// So we still need clusterIP rules in onlyNodeLocalEndpoints mode.</span></span><br><span class="line">			<span class="keyword">if</span> err := proxier.syncEndpoint(svcName, <span class="literal">false</span>, serv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"Failed to sync endpoint for service: %v, err: %v"</span>, serv, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">"Failed to sync service: %v, err: %v"</span>, serv, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Capture externalIPs.</span></span><br><span class="line">		<span class="keyword">for</span> _, externalIP := <span class="keyword">range</span> svcInfo.ExternalIPStrings() &#123;</span><br><span class="line">			<span class="comment">//....</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Capture load-balancer ingress.</span></span><br><span class="line">		<span class="keyword">for</span> _, ingress := <span class="keyword">range</span> svcInfo.LoadBalancerIPStrings() &#123;</span><br><span class="line">			<span class="comment">//.....</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> svcInfo.NodePort() != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">//....</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sync ipset entries</span></span><br><span class="line">	<span class="keyword">for</span> _, set := <span class="keyword">range</span> proxier.ipsetList &#123;</span><br><span class="line">		set.syncIPSetEntries()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tail call iptables rules for ipset, make sure only call iptables once</span></span><br><span class="line">	<span class="comment">// in a single loop per ip set.</span></span><br><span class="line">	proxier.writeIptablesRules()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sync iptables rules.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> NoFlushTables is used so we don't flush non-kubernetes chains in the table.</span></span><br><span class="line">	proxier.iptablesData.Reset()</span><br><span class="line">	proxier.iptablesData.Write(proxier.natChains.Bytes())</span><br><span class="line">	proxier.iptablesData.Write(proxier.natRules.Bytes())</span><br><span class="line">	proxier.iptablesData.Write(proxier.filterChains.Bytes())</span><br><span class="line">	proxier.iptablesData.Write(proxier.filterRules.Bytes())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>kube-proxy的代码逻辑还是比较简洁的，整体的思想就是kube-proxy服务去watch kubernetes集群的<code>Service</code>和<code>Endpoint</code>对象，当这两个资源对象有状态变化时，会把它们保存在<code>ServiceMap</code>和<code>EndPonintMap</code>中，然后会通过<code>async.BoundedFrequencyRunner</code>去异步的执行<code>syncProxyRules</code>去下发规则。</p>
</div><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/ipvs/">ipvs</a><a href="/tags/iptables/">iptables</a><a href="/tags/netfilter/">netfilter</a></div><div class="post-nav"><a class="pre" href="/2019/08/22/dns/">A DNS Refresher</a><a class="next" href="/2019/07/21/kubernetes-service/">浅谈Kubernetes Service负载均衡实现机制</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '86d1945e3a9358946043',
  clientSecret: '304f48ee3394ae5dab75d19a966506e170d850f6',
  repo: 'xigang.github.io',
  owner: 'xigang',
  admin: ['xigang'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://github.com/xigang"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etcd/">etcd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubernetes/">kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/microservices/">microservices</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志监控/">日志监控</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/etcd/" style="font-size: 15px;">etcd</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/kapacitor/" style="font-size: 15px;">kapacitor</a> <a href="/tags/alertmanager/" style="font-size: 15px;">alertmanager</a> <a href="/tags/bosun/" style="font-size: 15px;">bosun</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/cgroup/" style="font-size: 15px;">cgroup</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/dns/" style="font-size: 15px;">dns</a> <a href="/tags/coredns/" style="font-size: 15px;">coredns</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/prometheus/" style="font-size: 15px;">prometheus</a> <a href="/tags/kubeflow/" style="font-size: 15px;">kubeflow</a> <a href="/tags/scheduler/" style="font-size: 15px;">scheduler</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/kube-dns/" style="font-size: 15px;">kube-dns</a> <a href="/tags/microservices/" style="font-size: 15px;">microservices</a> <a href="/tags/ipvs/" style="font-size: 15px;">ipvs</a> <a href="/tags/iptables/" style="font-size: 15px;">iptables</a> <a href="/tags/netfilter/" style="font-size: 15px;">netfilter</a> <a href="/tags/lxcfs/" style="font-size: 15px;">lxcfs</a> <a href="/tags/mxnet/" style="font-size: 15px;">mxnet</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/10/k8s-namespace/">A Namespace Is Stuck in the Terminating State</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/statefulset-controller/">Kube-Controller-manager之StatefulSet Controller源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/kube-apisever/">Kube-apisever启动流程及API安装源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/lxcfs-admission-webhook/">使用Lxcfs和kubernetes Admission Webhook实现对容器资源可视化隔离</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/11/etcd-cluster-on-kubernetes/">Etcd Cluster on Kubernetes</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/21/client-go/">Kubernetes Client-Go Informer 实现源码剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/coredns/">CoreDNS源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/dns/">A DNS Refresher</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/kube-proxy-source-code/">Kube-Proxy  IPVS模式源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/kubernetes-service/">浅谈Kubernetes Service负载均衡实现机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://gogap.cn/" title="gogap" target="_blank">gogap</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">xigang's home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>