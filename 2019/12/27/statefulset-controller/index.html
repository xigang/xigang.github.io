<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Kube-Controller-manager之StatefulSet Controller源码解析 | xigang's home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kube-Controller-manager之StatefulSet Controller源码解析</h1><a id="logo" href="/.">xigang's home</a><p class="description">Do it right or don't do it at all</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kube-Controller-manager之StatefulSet Controller源码解析</h1><div class="post-meta">Dec 27, 2019<span> | </span><span class="category"><a href="/categories/kubernetes/">kubernetes</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>已经分析过了<code>deployment controller</code>, <code>replicaset controller</code>的具体实现逻辑,最近抽时间看了看<code>statefulset controller</code>的内部实现机制，目标是将kube-controller-manager的主要资源控制器的实现机制都深入的了解下。</p>
<a id="more"></a>
<h3 id="StatefulSet-Controller逻辑分析"><a href="#StatefulSet-Controller逻辑分析" class="headerlink" title="StatefulSet Controller逻辑分析"></a>StatefulSet Controller逻辑分析</h3><h4 id="startStatefulSetController"><a href="#startStatefulSetController" class="headerlink" title="startStatefulSetController"></a>startStatefulSetController</h4><p>statefulset控制器的主要实现逻辑如下图所示:</p>
<div align="left"><br><img src="http://p2.qhimg.com/t013f549e86a02c07f2.png" width="800" height="700" alt="statefulset"><br></div>

<p>接下来会针对上面的时序图对statefulset controller的具体实现逻辑，进行详细的分析:</p>
<p>statefulset controller的启动方式和其它的控制器的启动方式一样，如下代码所示:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func startStatefulSetController(ctx ControllerContext) (http<span class="selector-class">.Handler</span>, bool, error) &#123;</span><br><span class="line">	<span class="keyword">if</span> !ctx<span class="selector-class">.AvailableResources</span>[schema.GroupVersionResource&#123;Group: <span class="string">"apps"</span>, Version: <span class="string">"v1"</span>, Resource: <span class="string">"statefulsets"</span>&#125;] &#123;</span><br><span class="line">		return nil, false, nil</span><br><span class="line">	&#125;</span><br><span class="line">	go statefulset.NewStatefulSetController(</span><br><span class="line">		ctx<span class="selector-class">.InformerFactory</span><span class="selector-class">.Core</span>().V1().Pods(),</span><br><span class="line">		ctx<span class="selector-class">.InformerFactory</span><span class="selector-class">.Apps</span>().V1().StatefulSets(),</span><br><span class="line">		ctx<span class="selector-class">.InformerFactory</span><span class="selector-class">.Core</span>().V1().PersistentVolumeClaims(),</span><br><span class="line">		ctx<span class="selector-class">.InformerFactory</span><span class="selector-class">.Apps</span>().V1().ControllerRevisions(),</span><br><span class="line">		ctx<span class="selector-class">.ClientBuilder</span><span class="selector-class">.ClientOrDie</span>(<span class="string">"statefulset-controller"</span>),</span><br><span class="line">	).Run(int(ctx<span class="selector-class">.ComponentConfig</span><span class="selector-class">.StatefulSetController</span><span class="selector-class">.ConcurrentStatefulSetSyncs</span>), ctx.Stop)</span><br><span class="line">	return nil, true, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NewStatefulSetController</code>主要是对<code>StatefulSetController</code>结构进行初始化, 该结构的定义如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatefulSetController controls statefulsets.</span></span><br><span class="line">type StatefulSetController struct &#123;</span><br><span class="line">	<span class="comment">// client interface</span></span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line">	<span class="comment">// control returns an interface capable of syncing a stateful set.</span></span><br><span class="line">	<span class="comment">// Abstracted out for testing.</span></span><br><span class="line">	control StatefulSetControlInterface</span><br><span class="line">	<span class="comment">// podControl is used for patching pods.</span></span><br><span class="line">	podControl controller.PodControlInterface</span><br><span class="line">	<span class="comment">// podLister is able to list/get pods from a shared informer's store</span></span><br><span class="line">	podLister corelisters.PodLister</span><br><span class="line">	<span class="comment">// podListerSynced returns true if the pod shared informer has synced at least once</span></span><br><span class="line">	podListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// setLister is able to list/get stateful sets from a shared informer's store</span></span><br><span class="line">	setLister appslisters.StatefulSetLister</span><br><span class="line">	<span class="comment">// setListerSynced returns true if the stateful set shared informer has synced at least once</span></span><br><span class="line">	setListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// pvcListerSynced returns true if the pvc shared informer has synced at least once</span></span><br><span class="line">	pvcListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// revListerSynced returns true if the rev shared informer has synced at least once</span></span><br><span class="line">	revListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// StatefulSets that need to be synced.</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defaultStatefulSetControl需要实现<code>StatefulSetControlInterface</code>这个接口的所有方法:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type StatefulSetControlInterface<span class="built_in"> interface </span>&#123;</span><br><span class="line">	UpdateStatefulSet(<span class="builtin-name">set</span> <span class="number">*a</span>pps.StatefulSet, pods []*v1.Pod) error</span><br><span class="line">	ListRevisions(<span class="builtin-name">set</span> <span class="number">*a</span>pps.StatefulSet) ([]<span class="number">*a</span>pps.ControllerRevision, error)</span><br><span class="line">	AdoptOrphanRevisions(<span class="builtin-name">set</span> <span class="number">*a</span>pps.StatefulSet, revisions []<span class="number">*a</span>pps.ControllerRevision) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>UpdateStatefulSet用于实现statefulset controller的核心逻辑，比如: 扩容pod,删除pod,基于相应的更新策略更新pod等操作,也是实现statefulset controller最核心的方法.</li>
<li>ListRevisions获取每个statefulset关联的controller revisions,statefulset通过controller revsion来对指定版本的服务进行回滚操作.并通过revisionHistoryLimit参数来控制需要保留的revision的数量(默认是10).</li>
<li>AdoptOrphanRevisions用于statefulset去领养匹配的controller revision,通过ownerReference的方式进行领养.</li>
</ul>
<p>RealPodControl需要实现<code>PodControlInterface</code>这个接口的所有方法，这个接口内部的各个方法主要是对Pod进行创建，删除，更新操作。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type PodControlInterface<span class="built_in"> interface </span>&#123;</span><br><span class="line">	CreatePods(namespace string, template *v1.PodTemplateSpec, object runtime.Object) error</span><br><span class="line">	CreatePodsOnNode(nodeName, namespace string, template *v1.PodTemplateSpec, object runtime.Object, controllerRef *metav1.OwnerReference) error</span><br><span class="line">	CreatePodsWithControllerRef(namespace string, template *v1.PodTemplateSpec, object runtime.Object, controllerRef *metav1.OwnerReference) error</span><br><span class="line">	DeletePod(namespace string, podID string, object runtime.Object) error</span><br><span class="line">	PatchPod(namespace, name string, data []byte) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在statefulset controller中会去list/watch statefulset和pod这两种类型的资源对象，当这些资源对象有状态变化(ADD/DELETE/UPDATE)时，会被添加到queue中，被后续的syncHander去处理。</p>
<h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4><p>对<code>StatefulSetController</code>结构初始化完成之后，通过Run方法去启动statefulset控制器。<code>Run</code>方法代码实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the statefulset controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> ssc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	klog.Infof(<span class="string">"Starting stateful set controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> klog.Infof(<span class="string">"Shutting down statefulset controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"stateful set"</span>, stopCh, ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced, ssc.revListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.Until(ssc.worker, time.Second, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会通过<code>WaitForNamedCacheSync</code>去等待Pod和StatefulSet资源对象是否已经同步到Pod和StatefulSet Infomer中，如果已经同步过了之后，则会并发的启动指定数量的worker去从queue对statefulset进行处理(默认的并发数量是5, queue里面存储的是statefulset的key, worker会通过该key去cache中获取需要被处理的statefulset对象)。</p>
<h3 id="worker-amp-amp-processNextWorkItem"><a href="#worker-amp-amp-processNextWorkItem" class="headerlink" title="worker&amp;&amp;processNextWorkItem"></a>worker&amp;&amp;processNextWorkItem</h3><p>在worker方法中会去调用<code>processNextWorkItem</code>方法，然后在<code>processNextWorkItem</code>方法中，会去queue中串行的获取statefulset key,然后调用<code>sync</code>方法对获取的key进行处理，如果处理成功，则将该key从queue中forget掉，如果处理失败了，则将该key重新入队到queue中，等待下个syncloop去处理。</p>
<p><code>processNextWorkItem</code>的代码实现如下所示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := ssc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> ssc.queue.Done(key)</span><br><span class="line">	<span class="keyword">if</span> err := ssc.sync(key.(<span class="keyword">string</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Error syncing StatefulSet %v, requeuing: %v"</span>, key.(<span class="keyword">string</span>), err))</span><br><span class="line">		ssc.queue.AddRateLimited(key)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ssc.queue.Forget(key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><p>到了sync也就是对具体的某一个具体的statefulset进行逻辑任务处理了。在sync方法中主要做了下面几件事儿:</p>
<ol>
<li>调用SplitMetaNamespaceKey将statefulset key切分成namespace和name。(statefulset所在的namespace和statefulset的name).</li>
<li>通过statefulset namespace和name从statefulset controller的本地cache中获取具体的statefulset资源对象.</li>
<li>调用adoptOrphanRevisions方法对孤儿的controller revision进行领养。和deployment,replicaset,pod之间的领养关系一样，都是通过<code>OwnerReference</code>的方式进行领养。</li>
<li>调用getPodsForStatefulSet通过statefulset和selector来获取属于该statefulset下面所有的pod.</li>
<li>调用syncStatefulSet来维护statefulset和pods之间的关系。(这部分也就是statefulset controller的核心逻辑了)。</li>
</ol>
<p>关于sync方式的代码实现逻辑如下,除了<code>syncStatefulSet</code>核心方法接下来进行分析，其它的方法就不详细说明了。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">ssc</span> *StatefulSetController) sync(key string) <span class="keyword">error</span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		klog.V(4).Infof(<span class="string">"Finished syncing statefulset %q (%v)"</span>, key, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, name, <span class="keyword">err</span> := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span>, <span class="keyword">err</span> := <span class="keyword">ssc</span>.setLister.StatefulSets(namespace).<span class="built_in">Get</span>(name)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(<span class="keyword">err</span>) &#123;</span><br><span class="line">		klog.Infof(<span class="string">"StatefulSet has been deleted %v"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"unable to retrieve StatefulSet %v from store: %v"</span>, key, <span class="keyword">err</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	selector, <span class="keyword">err</span> := metav1.LabelSelectorAsSelector(<span class="keyword">set</span>.Spec.Selector)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"error converting StatefulSet %v selector: %v"</span>, key, <span class="keyword">err</span>))</span><br><span class="line">		<span class="comment">// This is a non-transient error, so don't retry.</span></span><br><span class="line">		<span class="keyword">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">ssc</span>.adoptOrphanRevisions(<span class="keyword">set</span>); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pods, <span class="keyword">err</span> := <span class="keyword">ssc</span>.getPodsForStatefulSet(<span class="keyword">set</span>, selector)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">ssc</span>.syncStatefulSet(<span class="keyword">set</span>, pods)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="syncStatefulSet"><a href="#syncStatefulSet" class="headerlink" title="syncStatefulSet"></a>syncStatefulSet</h4><p>syncStatefulSet方法是statefulset控制器的核心方法，该方法主要做了下面几件事儿:</p>
<ol>
<li>调用ListRevisions方法，获取属于该statefulset的所有controller revsion.然后通过SortControllerRevisions对controller revision基于创建的时间进行排序。</li>
<li>调用getStatefulSetRevisions方法获取statefulset的当前controller revison和update controller revision.如果是第一次创建statefulset则current和update controller revision相等。</li>
<li>调用updateStatefulSet方法来对statefulset进行pod的增加，删除，更新操作。</li>
<li>调用updateStatefulSetStatus方法来更新statefulset的状态信息。</li>
<li>调用truncateHistory方法来维护statefulset可以保留的controller revision数量，默认是10.</li>
</ol>
<p>syncStatefulSet的代码实现逻辑如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">ssc</span> *StatefulSetController) syncStatefulSet(<span class="keyword">set</span> *apps.StatefulSet, pods []*v1.Pod) <span class="keyword">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">ssc</span>.control.UpdateStatefulSet(<span class="keyword">set</span>.DeepCopy(), pods); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(4).Infof(<span class="string">"Successfully synced StatefulSet %s/%s successful"</span>, <span class="keyword">set</span>.Namespace, <span class="keyword">set</span>.Name)</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">ssc</span> *defaultStatefulSetControl) UpdateStatefulSet(<span class="keyword">set</span> *apps.StatefulSet, pods []*v1.Pod) <span class="keyword">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// list all revisions and sort them</span></span><br><span class="line">	revisions, <span class="keyword">err</span> := <span class="keyword">ssc</span>.ListRevisions(<span class="keyword">set</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	history.SortControllerRevisions(revisions)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get the current, and update revisions</span></span><br><span class="line">	currentRevision, updateRevision, collisionCount, <span class="keyword">err</span> := <span class="keyword">ssc</span>.getStatefulSetRevisions(<span class="keyword">set</span>, revisions)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// perform the main update function and get the status</span></span><br><span class="line">	status, <span class="keyword">err</span> := <span class="keyword">ssc</span>.updateStatefulSet(<span class="keyword">set</span>, currentRevision, updateRevision, collisionCount, pods)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update the set's status</span></span><br><span class="line">	<span class="keyword">err</span> = <span class="keyword">ssc</span>.updateStatefulSetStatus(<span class="keyword">set</span>, status)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// maintain the set's revision history limit</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">ssc</span>.truncateHistory(<span class="keyword">set</span>, pods, revisions, currentRevision, updateRevision)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来主要分析下updateStatefulSet方法的逻辑实现，UpdateStatefulSet中涉及的其它方法这里就不详细的介绍了。</p>
<h4 id="updateStatefulSet"><a href="#updateStatefulSet" class="headerlink" title="updateStatefulSet"></a>updateStatefulSet</h4><p>updateStatefulSet方法是statefulset的核心逻辑,该方法主要做了下面几件事儿:</p>
<p>1.首先通过currentRevsion和updateRevision去获取对应的statefulset,并更新statefulset的status。<br>2.将getPodsForStatefulSet方法中获取statefulset下的pods进行切分成replicas和condemned两个slices。<code>0 &lt;= ord(pod的序列号) &lt; replicaCount</code>的pod存放在replicas,而将<code>ord(pod的序列号) &gt;= replicaCount</code>的pod存放在condemned中，用于待删除处理。</p>
<p>这部分的代码实现逻辑如下:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := range pods &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">ord</span> := getOrdinal(pods[i]); <span class="number">0</span> &lt;= <span class="keyword">ord</span> &amp;&amp; <span class="keyword">ord</span> &lt; replicaCount &#123;</span><br><span class="line">			replicas[<span class="keyword">ord</span>] = pods[i]</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">ord</span> &gt;= replicaCount &#123;</span><br><span class="line">			condemned = append(condemned, pods[i])</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.如果replicas中存在某些ord(pod序列号)没有对应的Pod，则创建对应revision的Pod(通过newVersionedStatefulSetPod)，后面会检测到该Pod没有真实创建就会去创建对应的Pod实例。</p>
<p>这部分的代码实现逻辑如下:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">ord</span> := <span class="number">0</span>; <span class="keyword">ord</span> &lt; replicaCount; <span class="keyword">ord</span>++ &#123;</span><br><span class="line">		<span class="keyword">if</span> replicas[<span class="keyword">ord</span>] == nil &#123;</span><br><span class="line">			replicas[<span class="keyword">ord</span>] = newVersionedStatefulSetPod(</span><br><span class="line">				currentSet,</span><br><span class="line">				updateSet,</span><br><span class="line">				currentRevision.Name,</span><br><span class="line">				updateRevision.Name, <span class="keyword">ord</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>4.从repilcas和condemned pods两个slices中找出第一个unhealthy的Pod(ord最小的unhealth pod)。<br>5.对于正在删除(DeletionTimestamp != nil)的statefulset，不做任何操作，直接返回当前status。<br>6.遍历replicas中pods，保证replicas中index在[0，spec.replicas）的pod都是Running And Ready的, 具体的实现是:<br>        6.1 检查pod的状态是否处于Failed，如果是，则删除pod，更新status的状态,并创建新的pod对象<br>        6.2 如果pod没有被创建，则直接调用CreateStatefulPod去创建该pod，并更新statefulset的status. 并且当monotonic为fasle(就是非并行的创建pod)，则直接返回statefulset的status状态。<br>        6.3 如果pod处于删除状态(DeletionTimestamp != nil)并且monotoni设置为falase,则直接返回status,等待这个pod被删除之后，在继续做后续的处理工作。<br>        6.4 如果pod被创建，但是pod还没有达到<code>Running and Ready</code>的状态，则直接返回status,不继续做后续的处理工作。<br>        6.5 检查该pod与statefulset的identity和storage是否匹配，如果有一个不匹配，则调用apiserver Update Stateful Pod进行updateIdentity和updateStorage（并创建对应的PVC），返回status，结束</p>
<p>这部分代码的实现逻辑如下:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">		<span class="comment">// delete and recreate failed pods</span></span><br><span class="line">		<span class="keyword">if</span> isFailed(replicas[i]) &#123;</span><br><span class="line">			<span class="keyword">ssc</span>.recorder.Eventf(<span class="keyword">set</span>, v1.EventTypeWarning, <span class="string">"RecreatingFailedPod"</span>,</span><br><span class="line">				<span class="string">"StatefulSet %s/%s is recreating failed Pod %s"</span>,</span><br><span class="line">				<span class="keyword">set</span>.Namespace,</span><br><span class="line">				<span class="keyword">set</span>.Name,</span><br><span class="line">				replicas[i].Name)</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">ssc</span>.podControl.DeleteStatefulPod(<span class="keyword">set</span>, replicas[i]); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, <span class="keyword">err</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(replicas[i]) == currentRevision.Name &#123;</span><br><span class="line">				status.CurrentReplicas--</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(replicas[i]) == updateRevision.Name &#123;</span><br><span class="line">				status.UpdatedReplicas--</span><br><span class="line">			&#125;</span><br><span class="line">			status.Replicas--</span><br><span class="line">			replicas[i] = newVersionedStatefulSetPod(</span><br><span class="line">				currentSet,</span><br><span class="line">				updateSet,</span><br><span class="line">				currentRevision.Name,</span><br><span class="line">				updateRevision.Name,</span><br><span class="line">				i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we find a Pod that has not been created we create the Pod</span></span><br><span class="line">		<span class="keyword">if</span> !isCreated(replicas[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">ssc</span>.podControl.CreateStatefulPod(<span class="keyword">set</span>, replicas[i]); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, <span class="keyword">err</span></span><br><span class="line">			&#125;</span><br><span class="line">			status.Replicas++</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(replicas[i]) == currentRevision.Name &#123;</span><br><span class="line">				status.CurrentReplicas++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(replicas[i]) == updateRevision.Name &#123;</span><br><span class="line">				status.UpdatedReplicas++</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// if the set does not allow bursting, return immediately</span></span><br><span class="line">			<span class="keyword">if</span> monotonic &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, nil</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// pod created, no more work possible for this round</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we find a Pod that is currently terminating, we must wait until graceful deletion</span></span><br><span class="line">		<span class="comment">// completes before we continue to make progress.</span></span><br><span class="line">		<span class="keyword">if</span> isTerminating(replicas[i]) &amp;&amp; monotonic &#123;</span><br><span class="line">			klog.V(4).Infof(</span><br><span class="line">				<span class="string">"StatefulSet %s/%s is waiting for Pod %s to Terminate"</span>,</span><br><span class="line">				<span class="keyword">set</span>.Namespace,</span><br><span class="line">				<span class="keyword">set</span>.Name,</span><br><span class="line">				replicas[i].Name)</span><br><span class="line">			<span class="keyword">return</span> &amp;status, nil</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we have a Pod that has been created but is not running and ready we can not make progress.</span></span><br><span class="line">		<span class="comment">// We must ensure that all for each Pod, when we create it, all of its predecessors, with respect to its</span></span><br><span class="line">		<span class="comment">// ordinal, are Running and Ready.</span></span><br><span class="line">		<span class="keyword">if</span> !isRunningAndReady(replicas[i]) &amp;&amp; monotonic &#123;</span><br><span class="line">			klog.V(4).Infof(</span><br><span class="line">				<span class="string">"StatefulSet %s/%s is waiting for Pod %s to be Running and Ready"</span>,</span><br><span class="line">				<span class="keyword">set</span>.Namespace,</span><br><span class="line">				<span class="keyword">set</span>.Name,</span><br><span class="line">				replicas[i].Name)</span><br><span class="line">			<span class="keyword">return</span> &amp;status, nil</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Enforce the StatefulSet invariants</span></span><br><span class="line">		<span class="keyword">if</span> identityMatches(<span class="keyword">set</span>, replicas[i]) &amp;&amp; storageMatches(<span class="keyword">set</span>, replicas[i]) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Make a deep copy so we don't mutate the shared cache</span></span><br><span class="line">		replica := replicas[i].DeepCopy()</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">ssc</span>.podControl.UpdateStatefulPod(updateSet, replica); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;status, <span class="keyword">err</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>7.condemned中存储的pod是需要待删除的pod，对于这部分pod的删除，通常是从ord高序号开始进行pod的删除动作。具体的实现是:<br>    7.1 如果condemned[target]位置的pod处于正在删除的状态(DeletionTimestamp != nil)并且monotonic为false(意味着串行的处理pod),则直接返回statefulset的status.<br>    7.2 如果condemned[target]位置的pod的运行状态处于非<code>Runing and Ready</code>状态，并且monotonic为false同时还不是第一个不健康的pod，则等待该pod的状态处于<code>Running and Ready</code>的状态时，才允许删除，否则直接返回statefulset的status.<br>    7.3 如果上面的条件都通过了，则直接调用DeleteStatefulPod来对pod进行删除操作处理。并更新statefulset的status.</p>
<p>这部分的具体代码逻辑实现:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">for <span class="keyword">target</span> := len(condemned) - <span class="number">1</span>; <span class="keyword">target</span> &gt;= <span class="number">0</span>; <span class="keyword">target</span>-- &#123;</span><br><span class="line">		// <span class="keyword">wait</span> for terminating pods to expire</span><br><span class="line">		<span class="keyword">if</span> isTerminating(condemned[<span class="keyword">target</span>]) &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(</span><br><span class="line">				<span class="string">"StatefulSet %s/%s is waiting for Pod %s to Terminate prior to scale down"</span>,</span><br><span class="line">				set.Namespace,</span><br><span class="line">				set.<span class="keyword">Name</span>,</span><br><span class="line">				condemned[<span class="keyword">target</span>].<span class="keyword">Name</span>)</span><br><span class="line">			// block <span class="keyword">if</span> we are <span class="keyword">in</span> monotonic mode</span><br><span class="line">			<span class="keyword">if</span> monotonic &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;<span class="keyword">status</span>, nil</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		// <span class="keyword">if</span> we are <span class="keyword">in</span> monotonic mode and the condemned <span class="keyword">target</span> is not the first unhealthy Pod block</span><br><span class="line">		<span class="keyword">if</span> <span class="comment">!isRunningAndReady(condemned[target]) &amp;&amp; monotonic &amp;&amp; condemned[target] != firstUnhealthyPod &#123;</span></span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(</span><br><span class="line">				<span class="string">"StatefulSet %s/%s is waiting for Pod %s to be Running and Ready prior to scale down"</span>,</span><br><span class="line">				set.Namespace,</span><br><span class="line">				set.<span class="keyword">Name</span>,</span><br><span class="line">				firstUnhealthyPod.<span class="keyword">Name</span>)</span><br><span class="line">			<span class="keyword">return</span> &amp;<span class="keyword">status</span>, nil</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"StatefulSet %s/%s terminating Pod %s for scale down"</span>,</span><br><span class="line">			set.Namespace,</span><br><span class="line">			set.<span class="keyword">Name</span>,</span><br><span class="line">			condemned[<span class="keyword">target</span>].<span class="keyword">Name</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := ssc.podControl.DeleteStatefulPod(set, condemned[<span class="keyword">target</span>]); err <span class="comment">!= nil &#123;</span></span><br><span class="line">			<span class="keyword">return</span> &amp;<span class="keyword">status</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> getPodRevision(condemned[<span class="keyword">target</span>]) == currentRevision.<span class="keyword">Name</span> &#123;</span><br><span class="line">			<span class="keyword">status</span>.CurrentReplicas--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> getPodRevision(condemned[<span class="keyword">target</span>]) == updateRevision.<span class="keyword">Name</span> &#123;</span><br><span class="line">			<span class="keyword">status</span>.UpdatedReplicas--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> monotonic &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;<span class="keyword">status</span>, nil</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>8.对statefulset的更新策略(UpdateStrategy.Type)进行检查，判断是否是<code>OnDelete</code>的策略，如果是则直接返回statefulset的status. 在这里需要强调下的是，如果statefulset是<code>OnDelete</code>策略，则需要用户手动去删除pod之后，statefulset controller才会去启动新版本的pod实例。<br>9.对statefulset的更新策略(UpdateStrategy.Type)进行检查，如果是<code>RollingUpdate</code>策略，并且设置了<code>Partition</code>参数，则会计算出一个最小需要更新的updateMin值。这里也需要强调下，如果statefulset设置的更新策略是<code>RollingUpdate</code>，并且设置了<code>Partition</code>,则statefulset在更新时，会去更新<code>ord(pod序列号) &gt; Partition</code>的pod，如果设置的<code>Partition</code>大于<code>statefulset replicas</code>则不会进行新版本pod的更新操作。</p>
<p>这部分逻辑的代码实现:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">updateMin := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> set<span class="selector-class">.Spec</span><span class="selector-class">.UpdateStrategy</span><span class="selector-class">.RollingUpdate</span> != nil &#123;</span><br><span class="line">	updateMin = int(*set<span class="selector-class">.Spec</span><span class="selector-class">.UpdateStrategy</span><span class="selector-class">.RollingUpdate</span><span class="selector-class">.Partition</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.对[updateMin,len(replicas)]范围内的pod已index逆序的方式去做更新操作。<br>    10.1 首先去检查replicas[target]的revision是否等于<code>updateRevsion</code>，如果不是并且replicas[target]未处于删除的状态，则调用DeleteStatefulPod方法对该pod进行删除处理，并更新statefulset的status，并返回status.<br>    10.2 检查replicas[target]的pod是否处于<code>Running and Ready</code>状态，如果不是，则直接返回statefulset的status.等待该pod处于<code>Running and Ready</code>状态。</p>
<p>这部分逻辑代码实现:</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for target := len(replicas) - 1; target &gt;= updateMin; target-- &#123;</span><br><span class="line"></span><br><span class="line">	// <span class="keyword">delete</span> the Pod <span class="keyword">if</span> it <span class="keyword">is</span> <span class="keyword">not</span> already terminating <span class="keyword">and</span> does <span class="keyword">not</span> match the <span class="keyword">update</span> revision.</span><br><span class="line">	<span class="keyword">if</span> getPodRevision(replicas[target]) != updateRevision.Name &amp;&amp; !isTerminating(replicas[target]) &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"StatefulSet %s/%s terminating Pod %s for update"</span>,</span><br><span class="line">			<span class="keyword">set</span>.<span class="keyword">Namespace</span>,</span><br><span class="line">			<span class="keyword">set</span>.Name,</span><br><span class="line">			replicas[target].Name)</span><br><span class="line">		err := ssc.podControl.DeleteStatefulPod(<span class="keyword">set</span>, replicas[target])</span><br><span class="line">		status.CurrentReplicas--</span><br><span class="line">		<span class="keyword">return</span> &amp;status, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// wait <span class="keyword">for</span> unhealthy Pods <span class="keyword">on</span> <span class="keyword">update</span></span><br><span class="line">	<span class="keyword">if</span> !isHealthy(replicas[target]) &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(</span><br><span class="line">			<span class="string">"StatefulSet %s/%s is waiting for Pod %s to update"</span>,</span><br><span class="line">			<span class="keyword">set</span>.<span class="keyword">Namespace</span>,</span><br><span class="line">			<span class="keyword">set</span>.Name,</span><br><span class="line">			replicas[target].Name)</span><br><span class="line">		<span class="keyword">return</span> &amp;status, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的描述分析了statefulset controller的整体逻辑，在此做下记录：）</p>
<p>Fri Dec 27 10:55:31 CST 2019</p>
</div><div class="tags"><a href="/tags/kubernetes/">kubernetes</a></div><div class="post-nav"><a class="pre" href="/2020/02/10/k8s-namespace/">A Namespace Is Stuck in the Terminating State</a><a class="next" href="/2019/11/23/kube-apisever/">Kube-apisever启动流程及API安装源码分析</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '86d1945e3a9358946043',
  clientSecret: '304f48ee3394ae5dab75d19a966506e170d850f6',
  repo: 'xigang.github.io',
  owner: 'xigang',
  admin: ['xigang'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://github.com/xigang"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etcd/">etcd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubernetes/">kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/microservices/">microservices</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志监控/">日志监控</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/etcd/" style="font-size: 15px;">etcd</a> <a href="/tags/prometheus/" style="font-size: 15px;">prometheus</a> <a href="/tags/alertmanager/" style="font-size: 15px;">alertmanager</a> <a href="/tags/bosun/" style="font-size: 15px;">bosun</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/cgroup/" style="font-size: 15px;">cgroup</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a> <a href="/tags/dns/" style="font-size: 15px;">dns</a> <a href="/tags/coredns/" style="font-size: 15px;">coredns</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/kapacitor/" style="font-size: 15px;">kapacitor</a> <a href="/tags/kubeflow/" style="font-size: 15px;">kubeflow</a> <a href="/tags/scheduler/" style="font-size: 15px;">scheduler</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/microservices/" style="font-size: 15px;">microservices</a> <a href="/tags/ipvs/" style="font-size: 15px;">ipvs</a> <a href="/tags/iptables/" style="font-size: 15px;">iptables</a> <a href="/tags/netfilter/" style="font-size: 15px;">netfilter</a> <a href="/tags/kube-dns/" style="font-size: 15px;">kube-dns</a> <a href="/tags/lxcfs/" style="font-size: 15px;">lxcfs</a> <a href="/tags/mxnet/" style="font-size: 15px;">mxnet</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/10/k8s-namespace/">A Namespace Is Stuck in the Terminating State</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/statefulset-controller/">Kube-Controller-manager之StatefulSet Controller源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/kube-apisever/">Kube-apisever启动流程及API安装源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/lxcfs-admission-webhook/">使用Lxcfs和kubernetes Admission Webhook实现对容器资源可视化隔离</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/11/etcd-cluster-on-kubernetes/">Etcd Cluster on Kubernetes</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/21/client-go/">Kubernetes Client-Go Informer 实现源码剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/coredns/">CoreDNS源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/dns/">A DNS Refresher</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/kube-proxy-source-code/">Kube-Proxy  IPVS模式源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/kubernetes-service/">浅谈Kubernetes Service负载均衡实现机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://gogap.cn/" title="gogap" target="_blank">gogap</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">xigang's home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>