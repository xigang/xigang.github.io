<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kubernetes持久化存储Ceph RBD | xigang's home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kubernetes持久化存储Ceph RBD</h1><a id="logo" href="/.">xigang's home</a><p class="description">Do it right or don't do it at all</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kubernetes持久化存储Ceph RBD</h1><div class="post-meta">May 5, 2018<span> | </span><span class="category"><a href="/categories/kubernetes/">kubernetes</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>最近在调研kubernetes持久化存储，准备写一两篇关于这方面的文章，一是作为记录，二是可以给需要的同学作为一个参考。</p>
<h2 id="kubernetes存储的应用场景"><a href="#kubernetes存储的应用场景" class="headerlink" title="kubernetes存储的应用场景"></a>kubernetes存储的应用场景</h2><p>kubernetes中对于存储的使用主要集中在以下几个方面:</p>
<ul>
<li>服务配置文件读取，秘钥管理等。</li>
<li>服务的存储状态，数据存取等。</li>
<li>不同服务或应用程序之间共享数据。</li>
</ul>
<h2 id="kubernetes持久化概念"><a href="#kubernetes持久化概念" class="headerlink" title="kubernetes持久化概念"></a>kubernetes持久化概念</h2><p>kubernetes使用两种API资源来管理存储。分别是PersistentVolume和PersistentVolumeClaim。下面分别介绍下这两种资源的概念。</p>
<ul>
<li>PersistentVolume(简称PV):由管理员设置的存储，它是集群的一部分。就像节点(Node)是集群中的资源一样，PV也是集群中的资源。它包含存储类型，存储大小和访问模式。它的生命周期独立于Pod，例如当使用它的Pod销毁时对PV没有影响。</li>
<li>PersistentVolumeClaim(简称PVC): 是用户存储的请求。它和Pod类似。Pod消耗Node资源，PVC消耗PV资源。Pod可以请求特定级别的资源(CPU和MEM)。PVC可以请求特定大小和访问模式的PV。</li>
</ul>
<p>kubernetes可以使用三种方式来访问存储资源。</p>
<ul>
<li>直接访问</li>
</ul>
<p>该种方式移植性比较差，可扩展能力差，把Volume的基本信息完全暴露给用户，有安全隐患。</p>
<div align="left"><br><img src="http://p4.qhimg.com/t017a25d93292fcfa3a.jpg" width="400" height="360" alt="systemd"><br></div>

<ul>
<li>静态PV</li>
</ul>
<p>集群管理员创建一些PV。它们带有可供集群用户使用的实际存储的细节。之后便可用于PVC消费。(注意: 这种方式请求的PVC必须要与管理员创建的PV保持一致，如: 存储大小和访问模式)。否则不会将PVC绑定到PV上。</p>
<div align="left"><br><img src="http://p8.qhimg.com/t014f0ba883f8a80756.jpg" width="400" height="370" alt="systemd"><br></div>

<ul>
<li>动态PV</li>
</ul>
<p>当管理员创建的静态PV都不匹配用户的PVC,集群可以使用动态的为PVC创建卷。此配置基于StorageClass。PVC请求存储类(StorageClass),并且管理员必须要创建并配置该StorageClass,该StorageClass才能进行动态的创建。</p>
<div align="left"><br><img src="http://p1.qhimg.com/t01ee73e1891e8d38d5.jpg" width="400" height="360" alt="systemd"><br></div>

<h2 id="kubernetes数据持久化demo"><a href="#kubernetes数据持久化demo" class="headerlink" title="kubernetes数据持久化demo"></a>kubernetes数据持久化demo</h2><p>好了，上面已经对kubernetes持久化要用的概念进行了介绍，但是这些只是基本的概念，如果想要系统的了解请看官方文档：）</p>
<p>在实验前，你需要有一个可以使用的kubernetes和ceph集群，这里不介绍这两个集群的搭建了。<br>进行试验前最好先看下官方文档<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes" target="_blank" rel="noopener">persistent-volumes</a>。</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>kubernetes集群版本:1.9.0<br>ceph集群版本:10.2.10</p>
<h3 id="安装-ceph-common-包"><a href="#安装-ceph-common-包" class="headerlink" title="安装 ceph-common 包"></a>安装 ceph-common 包</h3><p>在kubernetes集群的所有Node上安装ceph-common包，具体的操作指令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y ceph-common</span></span><br></pre></td></tr></table></figure>
<h3 id="静态PV"><a href="#静态PV" class="headerlink" title="静态PV"></a>静态PV</h3><h5 id="创建ceph-secret"><a href="#创建ceph-secret" class="headerlink" title="创建ceph secret"></a>创建ceph secret</h5><p>在ceph mon节点运行<code>ceph auth get-key client.admin</code>命令获取admin的key。定义一个ceph secret文件。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: ceph-secret</span><br><span class="line">data:</span><br><span class="line">  key: <span class="attribute">QVFBOFF2SlZheUJQRVJBQWgvS2cwT1laQUhPQno3akZwekxxdGc9PQ</span>==</span><br></pre></td></tr></table></figure>
<p>注意: 文件中的key需要在ceph mon节点使用<code>ceph auth get-key client.admin | base64</code>命令对获取的key进行base64。</p>
<p>保存定义的文件，如<code>ceph-secret.yaml</code>, 之后创建一个secret:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl create -f ceph-secret.yaml </span></span><br><span class="line">secret <span class="string">"ceph-secret"</span> created</span><br></pre></td></tr></table></figure>
<h5 id="创建Persistent-Volume"><a href="#创建Persistent-Volume" class="headerlink" title="创建Persistent Volume"></a>创建Persistent Volume</h5><p>创建一个PV对象，使用下面文件的定义:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-pv</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">2</span><span class="string">Gi</span> </span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span> </span><br><span class="line"><span class="attr">  rbd:</span> </span><br><span class="line"><span class="attr">    monitors:</span> </span><br><span class="line"><span class="attr">      - mon-hosts:</span><span class="number">6789</span></span><br><span class="line"><span class="attr">    pool:</span> <span class="string">rbd</span> </span><br><span class="line"><span class="attr">    image:</span> <span class="string">ceph-image</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">    secretRef:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">ceph-secret</span> </span><br><span class="line"><span class="attr">    fsType:</span> <span class="string">ext4</span> </span><br><span class="line"><span class="attr">    readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br></pre></td></tr></table></figure>
<p>注意： 我们这里直接使用了ceph默认的pool rbd, 由于文件中使用了ceph-image，所以需要在ceph集群中创建该镜像。<code>rbd create ceph-image -s 128</code>。</p>
<p>保存定义的PV文件，如ceph-pv.yaml,并创建一个PV:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl create -f ceph-pv.yaml</span></span><br><span class="line"><span class="attribute">persistentvolume</span> <span class="string">"ceph-pv"</span> created</span><br></pre></td></tr></table></figure>
<p>查看PV的状态是否正常，如果获取的状态是Available则说明该PV处于可用状态，并且没有被PVC绑定。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get pv</span></span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM<span class="built_in"> POLICY </span>  STATUS      CLAIM                     STORAGECLASS   REASON    AGE</span><br><span class="line">ceph-pv     1Gi        RWO            Recycle          Available                                                      56s</span><br></pre></td></tr></table></figure>
<h5 id="创建Persistent-Volume-Claim"><a href="#创建Persistent-Volume-Claim" class="headerlink" title="创建Persistent Volume Claim"></a>创建Persistent Volume Claim</h5><p>PVC需要指定访问模式和存储的大小，当前只支持这两个属性，一个PVC绑定到一个PV上。一旦PV被绑定到PVC上就不能被其它的PVC所绑定。它们是一对一的关系。但是多个Pod可以使用同一个PVC进行卷的挂载。</p>
<p>PVC的定义文件如下:</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kind:</span> PersistentVolumeClaim</span><br><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> ceph-claim</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  accessModes:</span></span><br><span class="line">    - ReadWriteOnce</span><br><span class="line"><span class="symbol">  resources:</span></span><br><span class="line"><span class="symbol">    requests:</span></span><br><span class="line"><span class="symbol">      storage:</span> <span class="number">2</span>Gi</span><br></pre></td></tr></table></figure>
<p>保存定义的文件，并基于该文件创建PVC，并检查其状态，如果状态为Bound则说明该PVC已经绑定到PV,如果状态为Pending或Failed则表示PVC绑定PV失败,可用通过查看PVC事件或者kubernetes各个组件日志进行错误排查。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  kubectl create -f task-claim.yaml</span></span><br><span class="line"><span class="attribute">persistentvolumeclaim</span> <span class="string">"ceph-claim"</span> created</span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get pvc</span></span><br><span class="line">NAME              STATUS    <span class="keyword">VOLUME</span><span class="bash">      CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span></span><br><span class="line"><span class="bash">ceph-claim        Bound     ceph-pv     1Gi        RWO                           6s</span></span><br></pre></td></tr></table></figure>
<h5 id="创建Pod"><a href="#创建Pod" class="headerlink" title="创建Pod"></a>创建Pod</h5><p>定义一个Pod，在Pod里面启动一个container,并使用PVC去挂载Ceph RBD卷为读写模式。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: ceph-pod2           </span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: ceph-busybox</span><br><span class="line">    <span class="attribute">image</span>: busybox          </span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">"sleep"</span>, <span class="string">"60000"</span>]</span><br><span class="line">    <span class="attribute">volumeMounts</span>:</span><br><span class="line">    - <span class="attribute">name</span>: ceph-vol1       </span><br><span class="line">      <span class="attribute">mountPath</span>: /usr/share/busybox </span><br><span class="line">      <span class="attribute">readOnly</span>: false</span><br><span class="line">  <span class="attribute">volumes</span>:</span><br><span class="line">  - <span class="attribute">name</span>: ceph-vol1         </span><br><span class="line">    <span class="attribute">persistentVolumeClaim</span>:</span><br><span class="line">      <span class="attribute">claimName</span>: ceph-claim</span><br></pre></td></tr></table></figure>
<p>保存Pod的定义文件，如: ceph-pod.yaml。并创建该Pod。之后查看Pod的状态，如果Running则表示卷挂载成功，Pod正常运行。<br>这样便可以做个简单的操作，进行到该Pod的容器中，向<code>/usr/share/busybox</code>目录写入一些数据，之后删除该Pod，在创建一个新的Pod,看之前的数据是否还存在：）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#kubectl</span> create -f ceph-pod<span class="selector-class">.yaml</span> </span><br><span class="line">pod <span class="string">"ceph-pod2"</span> created</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">get</span> pods -o wide</span><br><span class="line">NAME                                READY     STATUS    RESTARTS   AGE      <span class="built_in"> IP </span>             NODE</span><br><span class="line">ceph-pod2                           1/1       Running   0          20s       10.x.x.x    hostname01</span><br></pre></td></tr></table></figure>
<h3 id="动态PV"><a href="#动态PV" class="headerlink" title="动态PV"></a>动态PV</h3><h5 id="创建RBD-pool"><a href="#创建RBD-pool" class="headerlink" title="创建RBD pool"></a>创建RBD pool</h5><p>虽然ceph提供了默认的pool rbd，但是建议创建一个新的pool为kubernetes持久化使用。在ceph的monitors节点创建一个名为<code>kube</code>的pool.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ceph osd pool create kube 1024</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ceph auth get-or-create client.kube mon <span class="string">'allow r'</span> osd <span class="string">'allow class-read object_prefix rbd_children, allow rwx pool=kube'</span> -o ceph.client.kube.keyring</span></span><br></pre></td></tr></table></figure>
<h5 id="创建ceph-secret-1"><a href="#创建ceph-secret-1" class="headerlink" title="创建ceph secret"></a>创建ceph secret</h5><p>与静态创建的ceph-secret是同一个，这里就不在重复创建。</p>
<h5 id="创建kube用户的ceph-secret"><a href="#创建kube用户的ceph-secret" class="headerlink" title="创建kube用户的ceph secret"></a>创建kube用户的ceph secret</h5><p>在ceph monitors节点运行命令<code>ceph auth get-key client.kube</code>获取kube用户的key。并对该用户key进行base64用于下面的文件。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: ceph-kube-secret</span><br><span class="line">  namespace: default</span><br><span class="line">data:</span><br><span class="line">  key: <span class="attribute">QVFCbEV4OVpmaGJtQ0JBQW55d2Z0NHZtcS96cE42SW1JVUQvekE9PQ</span>== </span><br><span class="line">type:</span><br><span class="line">  kubernetes.io/rbd</span><br></pre></td></tr></table></figure>
<p>保存定义的ceph secret文件，如ceph-kube-secret.yaml。执行如下命令创建secret:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl create -f ceph-kube-secret.yaml </span></span><br><span class="line">secret <span class="string">"ceph-kube-secret"</span> created</span><br></pre></td></tr></table></figure>
<p>查看secret是否创建成功。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get secret ceph-kube-secret</span></span><br><span class="line">NAME              <span class="built_in"> TYPE </span>               DATA      AGE</span><br><span class="line">ceph-kube-secret   kubernetes.io/rbd   1         2m</span><br></pre></td></tr></table></figure>
<h5 id="创建动态RBD-StorageClass"><a href="#创建动态RBD-StorageClass" class="headerlink" title="创建动态RBD StorageClass"></a>创建动态RBD StorageClass</h5><p>在创建StorageClass资源前,先介绍下StorageClass的概念:<code>StorageClass</code> 为管理员提供了描述存储<code>class</code>的方法。 不同的 <code>class</code> 可能会映射到不同的服务质量等级或备份策略，或由群集管理员确定的任意策略。 Kubernetes 本身不清楚各种 <code>class</code> 代表的什么。这个概念在其他存储系统中有时被称为“配置文件”。StorageClass不仅仅使用与ceph RBD还可以用于<code>Cinder</code>,<code>NFS</code>,<code>Glusterfs</code>等等。</p>
<p>好了，下面我们来创一个动态的storage class。定义文件如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kind</span>: StorageClass</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: dynamic</span><br><span class="line">  <span class="attribute">annotations</span>:</span><br><span class="line">     storageclass.beta.kubernetes.io/<span class="attribute">is-default-class</span>: <span class="string">"true"</span></span><br><span class="line"><span class="attribute">provisioner</span>: kubernetes.io/rbd</span><br><span class="line"><span class="attribute">parameters</span>:</span><br><span class="line">  <span class="attribute">monitors</span>: <span class="attribute">mon-hosts</span>:<span class="number">6789</span></span><br><span class="line">  <span class="attribute">adminId</span>: admin</span><br><span class="line">  <span class="attribute">adminSecretName</span>: ceph-secret</span><br><span class="line">  <span class="attribute">adminSecretNamespace</span>: kube-system</span><br><span class="line">  <span class="attribute">pool</span>: kube</span><br><span class="line">  <span class="attribute">userId</span>: kube</span><br><span class="line">  <span class="attribute">userSecretName</span>: ceph-kube-secret</span><br><span class="line">  <span class="attribute">fsType</span>: ext4</span><br><span class="line">  <span class="attribute">imageFormat</span>: <span class="string">"1"</span></span><br></pre></td></tr></table></figure>
<p>保存文件，并创建storage class。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kubectl create -f rbd-storage-<span class="keyword">class</span>.yaml </span><br><span class="line">storageclass <span class="string">"dynamic"</span> created</span><br></pre></td></tr></table></figure>
<p>检查storage class是否创建成功。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl <span class="keyword">get</span> storageclass</span><br><span class="line">NAME                PROVISIONER         AGE</span><br><span class="line"><span class="keyword">dynamic</span> (<span class="keyword">default</span>)   kubernetes.io/rbd   <span class="number">54</span>s</span><br></pre></td></tr></table></figure>
<h5 id="创建Persistent-Volume-Claim-1"><a href="#创建Persistent-Volume-Claim-1" class="headerlink" title="创建Persistent Volume Claim"></a>创建Persistent Volume Claim</h5><p>具体的描述细节请看创建静态PV时，对PVC的描述。或查看官方文档。下面我们直接定义PVC文件。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kind:</span> PersistentVolumeClaim</span><br><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> ceph-claim</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  accessModes:</span></span><br><span class="line">    rs ReadOnlyMany</span><br><span class="line"><span class="symbol">  resources:</span></span><br><span class="line"><span class="symbol">    requests:</span></span><br><span class="line"><span class="symbol">      storage:</span> <span class="number">1</span>Gi</span><br></pre></td></tr></table></figure>
<p>保存定义的文件，并创建该PVC。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl create -f static-ceph-pvc.yaml </span></span><br><span class="line"><span class="attribute">persistentvolumeclaim</span> <span class="string">"ceph-claim"</span> created</span><br></pre></td></tr></table></figure>
<p>检查PVC是否创建成功，并查看PVC的状态，如果PVC的状态为Bound则表示已经绑定到PV了。这里详细的说下，在kubernetes中一个指定访问模式和存储大小的PVC只能绑定到指定访问权限和存储大小的PV上，但是这样需要集群管理员手动的创建PV。这样就很麻烦，为了减少管理员的工作。管理员可以创建一个storageclass的资源，当指定规格的PVC请求的时候，StorageClass会动态的给该PVC提供一个PV。<br>我们查看下该PVC是否被该StorageClass绑定一个符合需求的PV上。我们执行下面的命令:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get pvc</span></span><br><span class="line">NAME              STATUS    <span class="keyword">VOLUME</span><span class="bash">                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span></span><br><span class="line"><span class="bash">ceph-claim        Bound     pvc-c32aca7e-38cd-11e8-af69-f0921c10a7bc   1Gi        ROX            dynamic        6s</span></span><br></pre></td></tr></table></figure>
<p>我们看到<code>ceph-claim</code>这个PVC已经绑定到了<code>pvc-c32aca7e-38cd-11e8-af69-f0921c10a7bc</code>这个PV,而该PV是由名为<code>dynamic</code>的storageclass动态创建的。</p>
<h5 id="创建Pod-1"><a href="#创建Pod-1" class="headerlink" title="创建Pod"></a>创建Pod</h5><p>我们定义一个Pod来将刚刚创建的PVC挂载到该Pod的容器中去。我们定义的Pod的文件内容如下:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: static-ceph-pod2</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: ceph-busybox</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">"sleep"</span>, <span class="string">"60000"</span>]</span><br><span class="line">    <span class="attribute">volumeMounts</span>:</span><br><span class="line">    - <span class="attribute">name</span>: ceph-vol1</span><br><span class="line">      <span class="attribute">mountPath</span>: /usr/share/busybox</span><br><span class="line">      <span class="attribute">readOnly</span>: false</span><br><span class="line">  <span class="attribute">volumes</span>:</span><br><span class="line">  - <span class="attribute">name</span>: ceph-vol1</span><br><span class="line">    <span class="attribute">persistentVolumeClaim</span>:</span><br><span class="line">      <span class="attribute">claimName</span>: ceph-claim</span><br></pre></td></tr></table></figure>
<p>保存定义Pod的文件，我们创建一个Pod:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pod static-ceph-pod2 </span><br><span class="line">NAME               READY     STATUS    RESTARTS   AGE</span><br><span class="line">static-ceph-pod2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">40</span>s</span><br></pre></td></tr></table></figure>
<p>ok, 已经成功的将该PVC挂载到了Pod中的容器中。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好了，到此为止，我们已经介绍了如何将kubernetes与ceph RBD关联起来，实现将被kubernetes编排的服务数据持久化。我们分别对静态PV和动态PV分别进行了实验，但是ceph RBD也有自己的缺点。</p>
<p>在说明ceoh RBD缺点之前，先介绍下PV的访问模式，PV支持三种访问模式。</p>
<p>模式包括:</p>
<ul>
<li>ReadWriteOnce——该卷可以被单个节点以读/写模式挂载</li>
<li>ReadOnlyMany——该卷可以被多个节点以只读模式挂载</li>
<li>ReadWriteMany——该卷可以被多个节点以读/写模式挂载</li>
</ul>
<p>但是ceph RBD只能进行单节点读写或多节点读，不能进行多节点读写，如下图所示：</p>
<div align="left"><br><img src="http://p6.qhimg.com/t016cc08526b5ade15d.png" width="400" height="370" alt="systemd"><br></div>

<p>但是有的业务可能需要多节点读写的功能，正好cephfs解决了这个问题，下篇文章我会介绍下cephfs如何与kubernetes结合实现数据持久化存储。</p>
</div><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/ceph/">ceph</a></div><div class="post-nav"><a class="pre" href="/2018/05/05/cephfs/">Kubernetes持久化存储cephfs</a><a class="next" href="/2018/05/05/kube-scheduler/">Kube-Scheduler源码解析</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '86d1945e3a9358946043',
  clientSecret: '304f48ee3394ae5dab75d19a966506e170d850f6',
  repo: 'xigang.github.io',
  owner: 'xigang',
  admin: ['xigang'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://github.com/xigang"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/etcd/">etcd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubernetes/">kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/microservices/">microservices</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志监控/">日志监控</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/prometheus/" style="font-size: 15px;">prometheus</a> <a href="/tags/alertmanager/" style="font-size: 15px;">alertmanager</a> <a href="/tags/bosun/" style="font-size: 15px;">bosun</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/cgroup/" style="font-size: 15px;">cgroup</a> <a href="/tags/kapacitor/" style="font-size: 15px;">kapacitor</a> <a href="/tags/etcd/" style="font-size: 15px;">etcd</a> <a href="/tags/kubeflow/" style="font-size: 15px;">kubeflow</a> <a href="/tags/scheduler/" style="font-size: 15px;">scheduler</a> <a href="/tags/microservices/" style="font-size: 15px;">microservices</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/mxnet/" style="font-size: 15px;">mxnet</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/cgroupv2/">CGROUPS VERSION 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/11/bosun/">Prometheus基于bosun框架进行告警</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/09/container-resource-metrics/">A Deep Dive Into Kubernetes Metrics - Container Resource Metrics</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/metrics-servere/">Kubernetes Metrics-Server介绍及源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/gang-scheduler/">适合AI场景的调度器 - Gang-Schedule</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/30/tensorflow/">Tensorflow结合kubeflow进行分布式训练</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/17/mxnet/">MXNet结合kubeflow进行分布式训练</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/31/Orphaned-pod/">定位 Orphaned Pod Found - but Volume Paths Are Still Present on Disk 问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/14/prometheus/">记一次InfoQ采访 <<360容器平台监控实践>></a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/08/kubeflow-intro/">Kubeflow使用Kubernetes进行机器学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://gogap.cn/" title="gogap" target="_blank">gogap</a><ul></ul><a href="http://www.0x7c00.net/" title="31744" target="_blank">31744</a><ul></ul><a href="https://www.opsdev.cn/" title="360opsdev" target="_blank">360opsdev</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">xigang's home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>