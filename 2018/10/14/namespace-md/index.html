<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>浅谈 Linux Namespace | xigang's home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅谈 Linux Namespace</h1><a id="logo" href="/.">xigang's home</a><p class="description">Do it right or don't do it at all</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浅谈 Linux Namespace</h1><div class="post-meta">Oct 14, 2018<span> | </span><span class="category"><a href="/categories/Linux/">Linux</a></span></div><div class="post-content"><p>对于搞云计算的同学，对容器技术大家应该都不会陌生,容器的资源限制使用的底层技术是<code>cgroups</code>并且容器的隔离使用的是<code>Linux Namespace</code>机制。之前的文章简单的介绍了<a href="https://xigang.github.io/2018/07/08/cgroups/" target="_blank" rel="noopener">Linux cgroups</a>。通过本篇文章来给大家介绍下<code>Linux Namespace</code>的机制。</p>
<h3 id="Linux-namespaces-介绍"><a href="#Linux-namespaces-介绍" class="headerlink" title="Linux namespaces 介绍"></a>Linux namespaces 介绍</h3><p><code>namespaces</code>是Linux内核用来隔离内核资源的方式。通过<code>namespaces</code>可以让一些进程只能看到与自己相关的那部分资源。而其它的进程也只能看到与他们自己相关的资源。这两拨进程根本感知不到对方的存在。而它具体的实现细节是通过<code>Linux namespaces</code>来实现的。</p>
<p><code>总结</code>: <code>Linux namespaces</code>对系统进程进行轻量的虚拟化隔离。</p>
<p>当前Linux内核只支持6中<code>namespaces</code>:</p>
<ul>
<li>mnt(mount points, filesystems)</li>
<li>pid(process)</li>
<li>net(network stack)</li>
<li>ipc(System V IPC)</li>
<li>uts(hostname)</li>
<li>user(UIDs)</li>
</ul>
<p>下面是<code>Linux Kernel</code>版本迭代过程中对这6中namespaces的支持情况及对应的<code>flag</code>:</p>
<p><div align="left"><br><img src="http://p6.qhimg.com/t014635bb8c6f3dac3d.png" width="800" height="320" alt="namespace"></div></p>
<p>最初打算对Linux内核支持10种<code>namespaces</code>,但是下面的4中没有实现:</p>
<ul>
<li>security namespace</li>
<li>security keys namespaces</li>
<li>device namespace</li>
<li>time namespace</li>
</ul>
<p>接下来先介绍namespace的API,然后在针对Linux内核现在支持的6中namespace分别进行介绍。</p>
<h3 id="Namespaces-API-介绍"><a href="#Namespaces-API-介绍" class="headerlink" title="Namespaces API 介绍"></a>Namespaces API 介绍</h3><p>下面3个系统调用API会被用于namespaces:</p>
<ul>
<li>clone(): 用于创建新的进程同时创建新的<code>namespaces</code>。并且新的进程会被<code>attach</code>到新的<code>namespace</code>里面。</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int clone(<span class="name">int</span> (<span class="name">*fn</span>)(<span class="name">void</span> *), void *child_stack,</span><br><span class="line">       int flags, void *arg, ...</span><br><span class="line">       /* pid_t *ptid, void *newtls, pid_t *ctid */ )<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数child_func传入子进程运行的程序主函数。</li>
<li>参数child_stack传入子进程使用的栈空间</li>
<li>参数flags表示使用哪些CLONE_*标志位</li>
<li>参数args则可用于传入用户参数</li>
</ul>
<p><code>ClONE_NEW*</code> flag有20多被包含在<code>include/linux/sched.h</code>头文件中。</p>
<ul>
<li>unshare(): 不会创建新的进程，但是会创建新的namesapce并把当前的进程<code>attach</code>到该namespace里面。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unshare</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>setns(): 将进程<code>attach</code>到一个已经存在的namespace里面。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setns</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> nstype)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数fd表示我们要加入的namespace的文件描述符。如:/proc/[pid]/ns下面对应的文件描述符。</li>
<li>参数nstype让调用者可以去检查fd指向的namespace类型是否符合我们实际的要求。如果填0表示不检查。</li>
</ul>
<h3 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h3><p><code>UTS namespace</code>提供了主机名和域名的隔离，这样每一个容器就可以拥有独立的主机名和域名，在网络上可以被视为一个独立的节点而非宿主机上的一个进程。</p>
<p>下面让我们来看下UTS的隔离效果，测试代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">	<span class="string">"/bin/bash"</span>,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"in child process!\n"</span>);</span><br><span class="line">	sethostname(<span class="string">"changed namespace"</span>, <span class="number">12</span>);</span><br><span class="line">	execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"program begin: \n"</span>);</span><br><span class="line">	<span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD|CLONE_NEWUTS, <span class="literal">NULL</span>);</span><br><span class="line">	waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"quit\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是main中在调用<code>clone</code>函数创建新进程及新namespace的时候，传递了<code>CLONE_NEWUTS</code>flag,用于对主机名和域名的隔离。</p>
<p>编译并运行程序会发现主机名发生了变化。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># gcc -Wall uts.c -o uts &amp;&amp; ./uts</span></span><br><span class="line">program begin:</span><br><span class="line"><span class="keyword">in</span> child process!</span><br><span class="line">[root@changed name ~]<span class="comment"># exit</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">quit</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>每个容器的主机名不同就是使用<code>UTS Namespace</code>机制实现的。</p>
<h3 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h3><p>容器中进程间的通信采用的方式包括: <code>信号量</code>，<code>消息队列</code>和<code>共享内存</code>。与虚拟机不同的是，容器内部进程间通信对宿主机来说，实际上是具有相同的<code>PID namespace</code>中的进程间通信，因此需要一个而唯一的标识符来进行区别。申请IPC资源就申请了这样一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，而与其他的IPC namespace下的进程则互相不可见。</p>
<p>下面我们来看下IPC的隔离效果，测试代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">	<span class="string">"/bin/bash"</span>,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"in child process!\n"</span>);</span><br><span class="line">	sethostname(<span class="string">"changed namespace"</span>, <span class="number">12</span>);</span><br><span class="line">	execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"program begin: \n"</span>);</span><br><span class="line">	<span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC, <span class="literal">NULL</span>);</span><br><span class="line">	waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"quit\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数中调用<code>clone</code>函数创建新进程同时创建新namespaces的时候，传递<code>CLONE_NEWIPC</code>flag, 来实现进程间<code>IPC</code>的隔离。</p>
<p>在运行程序的时候，为了方便测试进程间通信是否被真正的隔离了，</p>
<p>1.首先我们先使用<code>ipcmk -Q</code>命令创建一个<code>queue</code>:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@locahost ~]<span class="comment"># ipcmk -Q</span></span><br><span class="line">消息队列 <span class="built_in">id</span>：<span class="number">32769</span></span><br></pre></td></tr></table></figure>
<p>2.使用<code>ipcs -q</code>查看<code>queue</code>是否创建成功:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ipcs -q</span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span><br><span class="line"><span class="number">0x6d2ba356</span> <span class="number">0</span>          root       <span class="number">644</span>        <span class="number">0</span>            <span class="number">0</span></span><br><span class="line"><span class="number">0xe88b6229</span> <span class="number">32769</span>      root       <span class="number">644</span>        <span class="number">0</span>            <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3.编译并运行ipc.c代码对<code>IPC</code>进行隔离并进行验证:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span>~]<span class="comment"># gcc -Wall ipc.c -o ipc &amp;&amp; ./ipc</span></span><br><span class="line">program <span class="keyword">begin</span>:</span><br><span class="line"><span class="keyword">in</span> child process!</span><br><span class="line">[root<span class="meta">@changed</span> name ~]<span class="comment"># ipcs -q</span></span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span><br></pre></td></tr></table></figure>
<p>从运行的结果来看，已经找不到原先声明的message queue，实现了IPC的隔离。</p>
<h3 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h3><p><code>PID namespace</code>隔离非常实用，它对进程PID重新标号,即两个不同的namespace下的进程可以拥有同一个PID。每一个PID namespace都有字的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的,即root namespace。他创建的新的PID namespace称child namespace。通过这种方式，不同的PID namespace会形成一个等级的体系。所属的父节点可以看到子节点中的进程，并可以通过信号等方式对子节点中的进程产生影响。反过来，子节点不能看到父节点PID namespace中的任何内容。</p>
<p>由此产生如下结论：</p>
<ul>
<li>每个PID namespace中的第一个进程“PID 1“，都会像传统Linux中的init进程一样拥有特权，起特殊作用。</li>
<li>一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。</li>
<li>如果你在新的PID namespace中重新挂载/proc文件系统，会发现其下只显示同属一个PID namespace中的其他进程。</li>
<li>在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。</li>
</ul>
<p>下面我们来看下对PID的隔离效果，测试代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">	<span class="string">"/bin/bash"</span>,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"in child process!\n"</span>);</span><br><span class="line">	sethostname(<span class="string">"changed namespace"</span>, <span class="number">12</span>);</span><br><span class="line">	execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"program begin: \n"</span>);</span><br><span class="line">	<span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC, <span class="literal">NULL</span>);</span><br><span class="line">	waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"quit\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数中调用<code>clone</code>函数创建新的进程同时创建新的namespace的时候，传递<code>CLONE_NEWPID</code> flag。来实现对PIDg隔离。</p>
<p>让我们编译并运行代码，看下效果：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> ~]<span class="comment"># gcc -Wall pid.c -o pid &amp;&amp; ./pid</span></span><br><span class="line">program <span class="keyword">begin</span>:</span><br><span class="line"><span class="keyword">in</span> child process!</span><br><span class="line">[root<span class="meta">@changed</span> name ~]<span class="comment"># ps aux</span></span><br></pre></td></tr></table></figure>
<p>运行<code>ps aux</code>命令来查看是否实现了<code>PID namespace</code>的隔离；发现还会看到宿主机上的所有的进程。这是由于没有对文件系统进行隔离，ps/top之类的命令调用的是真实系统下的/proc文件内容，看到的自然是所有的进程。</p>
<p>运行下面的mount命令来对<code>/proc</code> 文件系统进行隔离:</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@changed name ~]# mount -t <span class="keyword">proc</span><span class="title"> proc</span> /<span class="keyword">proc</span></span><br><span class="line">[root@changed<span class="title"> name</span> ~]#<span class="title"> ps</span> uax</span><br><span class="line">USER<span class="title">       PID</span> %CPU %MEM<span class="title">    VSZ</span> <span class="title">  RSS</span> TTY<span class="title">      STAT</span> START<span class="title">   TIME</span> COMMAND</span><br><span class="line">root         1  0.0  0.0 122804  4172<span class="title"> pts/1</span> <span class="title">   S</span>    20:39   0:00 /bin/bash</span><br><span class="line">root        37  0.0  0.0   5184   340<span class="title"> pts/1</span> <span class="title">   S</span>    20:40   0:00 ./uts</span><br><span class="line">root        38  0.0  0.0 122804  4176<span class="title"> pts/1</span> <span class="title">   S</span>    20:40   0:00 /bin/bash</span><br><span class="line">root        68  0.0  0.0 151056  1816<span class="title"> pts/1</span> <span class="title">   R+</span>   20:42   0:00<span class="title"> ps</span> uax</span><br></pre></td></tr></table></figure>
<p>看到达到了对<code>PID namespace</code>隔离的效果。</p>
<h3 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h3><p>Mount namespace通过隔离文件系统挂载点对隔离文件系统提供支持。隔离后，不同的mount namespace中的文件结构发生变化也互不影响。你可以通过<code>/proc/[pid]/mounts</code>查看到所有挂载在当前namesapce中的文件系统，还可以通过<code>/proc/[pid]/mountstats</code>看到<code>mount namespace</code>中文件设备的统计信息，包括挂载的文件名称，文件系统类型，挂载位置等等。</p>
<p>进程在创建mount namespace的时候，会把当前结构复制给新的namespace。 新的namespace中的所有mount操作都影响自身的文件系统，而对外界不会产生任何影响。这样做就严格地实现了隔离。</p>
<p>让我们来对文件系统进行隔离，测试的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="comment">// sync primitive</span></span><br><span class="line"><span class="keyword">int</span> checkpoint[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">	<span class="string">"/bin/bash"</span>,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="comment">// init sync primitive</span></span><br><span class="line">	close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">// setup hostname</span></span><br><span class="line">	sethostname(<span class="string">"changed namespace"</span>, <span class="number">12</span>);</span><br><span class="line">	<span class="comment">// remount "/proc" to get accurate "top" &amp;&amp; "ps" output</span></span><br><span class="line">	mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// wait...</span></span><br><span class="line">	read(checkpoint[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">	execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Ooops\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// init sync primitive</span></span><br><span class="line">	pipe(checkpoint);</span><br><span class="line">	<span class="keyword">int</span> child_pid = clone(child_main, child_stack+STACK_SIZE,</span><br><span class="line">	  CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// further init here (nothing yet)</span></span><br><span class="line">	<span class="comment">// signal "done"</span></span><br><span class="line">	close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">	waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"quit!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数中调用<code>clone</code>函数创建新进程同时创建新的namespace时，需要增加<code>CLONE_NEWNS</code> flag。来实现对<code>Mount namespace</code>的隔离。</p>
<p>下面让我们编译并运行下程序来验证是否实现了对文件系统的隔离。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gcc -Wall mntns.c -o mnt &amp;&amp; ./mnt</span><br><span class="line">[root@changed name ~]# ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.7  0.0 122804  4100 pts/0    S    13:27   0:00 /bin/bash</span><br><span class="line">root        30  0.0  0.0 151056  1816 pts/0    R+   13:28   0:00 ps aux</span><br></pre></td></tr></table></figure>
<p>从上面程序执行输出的结果可以看到，已经实现了对文件系统的隔离。关于<code>mount</code>相关的知识很多。这里就具体的详细介绍了，如果感兴趣可以看下:</p>
<p><a href="https://lwn.net/Articles/689856/" target="_blank" rel="noopener">Mount namespaces and shared subtrees</a><br><a href="http://man7.org/linux/man-pages/man8/mount.8.html" target="_blank" rel="noopener">mount a filesystem</a></p>
<h3 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h3><p>Net namespace主要提供关于网络资源的隔离，包括网络设备IPv4和IPv6协议栈，IP路由表，防火墙，/proc/net目录，/sys/class/net目录，端口等等。一个物理的网络设备最多存在一个<code>net  namespace</code>中，你可以创建<code>veth pair</code>(虚拟网路设备对:有两端如果有数据从一端传入另一端也能收到，反之亦然)在不同的network namespace间创建通道依次达到通信的目的。</p>
<p>一般情况下，物理网络设备都分配在最初的root namespace中，但是如果你有多块物理网卡，也可以把其中一块或多块分配给新创建的network namespace。需要注意的是，当新创建的network namespace被释放时（所有内部的进程都终止并且namespace文件没有被挂载或打开），在这个namespace中的物理网卡会返回到root namespace而非创建该进程的父进程所在的network namespace。</p>
<p>当我们说到network namespace时，其实我们指的未必是真正的网络隔离，而是把网络独立出来，给外部用户一种透明的感觉，仿佛跟另外一个网络实体在进行通信。为了达到这个目的，容器的经典做法就是创建一个veth pair，一端放置在新的namespace中，通常命名为eth0，一端放在原先的namespace中连接物理网络设备，再通过网桥把别的设备连接进来或者进行路由转发，以此网络实现通信的目的。</p>
<p>也许有读者会好奇，在建立起veth pair之前，新旧namespace该如何通信呢？答案是pipe（管道）。我们以Docker Daemon在启动容器dockerinit的过程为例。Docker Daemon在宿主机上负责创建这个veth pair，通过netlink调用，把一端绑定到docker0网桥上，一端连进新建的network namespace进程中。建立的过程中，Docker Daemon和dockerinit就通过pipe进行通信，当Docker Daemon完成veth-pair的创建之前，dockerinit在管道的另一端循环等待，直到管道另一端传来Docker Daemon关于veth设备的信息，并关闭管道。dockerinit才结束等待的过程，并把它的“eth0”启动起来。整个效果类似下图所示。</p>
<p><div align="left"><br><img src="http://p3.qhimg.com/t018def5b691ae3e35b.png" width="800" height="450" alt="namespace"></div></p>
<p>跟其他namespace类似，对network namespace的使用其实就是在创建的时候添加CLONE_NEWNET标识位。也可以通过命令行工具ip创建network namespace。在代码中建立和测试network namespace较为复杂，所以下文主要通过ip命令直观的感受整个network namespace网络建立和配置的过程。</p>
<p>首先我们可以创建一个命名为test_ns的network namespace:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@localhost ~]#<span class="built_in"> ip </span>netns <span class="builtin-name">add</span> test_ns</span><br></pre></td></tr></table></figure>
<p>当ip命令工具创建一个network namespace时，会默认创建一个回环设备（loopback interface：lo），并在/var/run/netns目录下绑定一个挂载点，这就保证了就算network namespace中没有进程在运行也不会被释放，也给系统管理员对新创建的network namespace进行配置提供了充足的时间。</p>
<p>通过ip netns exec命令可以在新创建的network namespace下运行网络管理命令。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>netns exec test_ns<span class="built_in"> ip </span>link list</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode<span class="built_in"> DEFAULT </span>qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>
<p>上面的命令为我们展示了新建的namespace下可见的网络链接，可以看到状态是DOWN,需要再通过命令去启动。可以看到，此时执行ping命令是无效的。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>netns exec test_ns<span class="built_in"> ping </span>127.0.01</span><br><span class="line">connect: 网络不可达</span><br></pre></td></tr></table></figure>
<p>启动命令如下，可以看到启动后再测试就可以ping通。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>netns exec test_ns<span class="built_in"> ip </span>link <span class="builtin-name">set</span> dev lo up</span><br><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>netns exec test_ns<span class="built_in"> ip </span>link list</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode<span class="built_in"> DEFAULT </span>qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>netns exec test_ns<span class="built_in"> ping </span>127.0.0.1</span><br><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 127.0.0.1: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.087 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 127.0.0.1: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.060 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 127.0.0.1: <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.062 ms</span><br></pre></td></tr></table></figure>
<p>这样只是启动了本地的回环，要实现与外部namespace进行通信还需要再建一个网络设备对，命令如下。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>link <span class="builtin-name">add</span> veth0<span class="built_in"> type </span>veth<span class="built_in"> peer </span>name veth1</span><br><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>link <span class="builtin-name">set</span> veth1 netns test_ns</span><br><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>netns exec test_ns ifconfig veth1 10.1.1.1/24 up</span><br><span class="line">[root@localhost ~]# ifconfig veth0 10.1.1.2/24 up</span><br></pre></td></tr></table></figure>
<ul>
<li>第一条命令创建了一个网络设备对，所有发送到veth0的包veth1也能接收到，反之亦然</li>
<li>第二条命令则是把veth1这一端分配到test_ns这个network namespace。</li>
<li>第三、第四条命令分别给test_ns内部和外部的网络设备配置IP，veth1的IP为10.1.1.1，veth0的IP为10.1.1.2。</li>
</ul>
<p>此时两边就可以互相连通了，效果如下。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@localhost ~]#<span class="built_in"> ping </span>10.1.1.1</span><br><span class="line">PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.1.1.1: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.038 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.1.1.1: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.057 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.1.1.1<span class="built_in"> ping </span>statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.038/0.047/0.057/0.011 ms</span><br><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>netns exec test_ns<span class="built_in"> ping </span>10.1.1.2</span><br><span class="line">PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.1.1.2: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.048 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.1.1.2: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.060 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.1.1.2<span class="built_in"> ping </span>statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.048/0.054/0.060/0.006 ms</span><br></pre></td></tr></table></figure>
<p>删除<code>net namespace</code>:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#<span class="built_in"> ip </span>netns delete test_ns</span><br></pre></td></tr></table></figure>
<h3 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h3><p><code>注意</code>:User namespace是Linux内核(Linux 3.8)最后支持的namespace，所以有的版本的系统内核可能还没有对该namespace支持。</p>
<p>User namespace主要隔离了安全相关的标识符和属性，包括用户ID,用户组ID,root目录等。通俗点就是: 一个普通用户的进程通过clone()创建新的进程在新user namespace中可以拥有不同的用户和用户组。这意味着一个进程在容器外属于一个没有特殊权限的普通用户，但是它创建的容器进程却属于拥有所有权限的超级用户，这个技术为容器提供了极大的自由。</p>
<p>Linux中，特权用户的user ID是0，演示的最终我们将看到user ID非0的进程启动user namespace后user ID可以变为0。使用user namespace的方法和其它的namespace的使用方式没有太大的区别。即调用clone()的时候，需要加入<code>CLONE_NEWUSER</code>标识位。</p>
<p>让我们来看下user namespace的隔离效果，测试代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">  <span class="string">"/bin/bash"</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"in child program!\n"</span>);</span><br><span class="line">  <span class="keyword">cap_t</span> caps;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"eUID = %ld; eGID = %ld;"</span>, (<span class="keyword">long</span>)geteuid(), (<span class="keyword">long</span>)getegid());</span><br><span class="line">  caps = cap_get_proc();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"capabilities: %s\n"</span>, cap_to_text(caps, <span class="literal">NULL</span>));</span><br><span class="line">  execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译并执行代码之前，我们先来看下当前的用户uid和gid.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> id -u</span></span><br><span class="line">1000</span><br><span class="line"><span class="meta">$</span><span class="bash"> id -g</span></span><br><span class="line">1000</span><br></pre></td></tr></table></figure>
<p>现在编译并运行我们的代码来验证user namespace是否隔离成功：<br><code>注意</code>: 如果编译时如下报错:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="keyword">error</span>: sys/capability.h: No such <span class="built_in">file</span> <span class="keyword">or</span> directory</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>
<p>则在<code>ubuntu</code>编译则需要安装<code>libcap-dev</code>包,如果在<code>centos</code>上编译则需要安装<code>libcap-devel</code>包。</p>
<p>运行的结果如下:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gcc userns.c -Wall -lcap -o userns &amp;&amp; ./userns </span><br><span class="line"><span class="function"><span class="keyword">program</span></span> begin: </span><br><span class="line"><span class="keyword">in</span> child <span class="function"><span class="keyword">program</span></span><span class="comment">!</span></span><br><span class="line">eUID = <span class="number">65534</span>; eGID = <span class="number">65534</span>;capabilities: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,<span class="number">37</span>+ep</span><br></pre></td></tr></table></figure>
<p>通过验证我们可以得到以下信息。</p>
<ul>
<li>user namespace被创建后，第一个进程被赋予了该namespace中的全部权限，这样这个init进程就可以完成所有必要的初始化工作，而不会因权限不足而出现错误。</li>
<li>我们看到namespace内部看到的UID和GID已经与外部不同了，默认显示为65534，表示尚未与外部namespace用户映射。我们需要对user namespace内部的这个初始user和其外部namespace某个用户建立映射，这样可以保证当涉及到一些对外部namespace的操作时，系统可以检验其权限（比如发送一个信号或操作某个文件）。同样用户组也要建立映射。</li>
<li>还有一点虽然不能从输出中看出来，但是值得注意。用户在新namespace中有全部权限，但是他在创建他的父namespace中不含任何权限。就算调用和创建他的进程有全部权限也是如此。所以哪怕是root用户调用了clone()在user namespace中创建出的新用户在外部也没有任何权限。</li>
<li>最后，user namespace的创建其实是一个层层嵌套的树状结构。最上层的根节点就是root namespace，新创建的每个user namespace都有一个父节点user namespace以及零个或多个子节点user namespace，这一点与PID namespace非常相似。</li>
</ul>
<p>接下来我们就要进行用户绑定操作，通过在/proc/[pid]/uid_map和/proc/[pid]/gid_map两个文件中写入对应的绑定信息可以实现这一点，格式如下。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID-inside-ns   ID-outside-ns   length</span><br></pre></td></tr></table></figure>
<p>写这两个文件需要注意以下几点。</p>
<ul>
<li>两个文件只允许由拥有该user namespace中CAP_SETUID权限的进程写入一次，不允许修改。</li>
<li>写入的进程必须是该user namespace的父namespace或者子namespace。</li>
<li>第一个字段ID-inside-ns表示新建的user namespace中对应的user/group ID，第二个字段ID-outside-ns表示namespace外部映射的user/group ID。最后一个字段表示映射范围，通常填1，表示只映射一个，如果填大于1的值，则按顺序建立一一映射。</li>
</ul>
<p>明白了上述原理，我们再次修改代码，添加设置uid和guid的函数。测试的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">  <span class="string">"/bin/bash"</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_uid_map</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">"/proc/%d/uid_map"</span>, getpid());</span><br><span class="line">    FILE* uid_map = fopen(path, <span class="string">"w"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(uid_map, <span class="string">"%d %d %d"</span>, inside_id, outside_id, length);</span><br><span class="line">    fclose(uid_map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_gid_map</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">"/proc/%d/gid_map"</span>, getpid());</span><br><span class="line">    FILE* gid_map = fopen(path, <span class="string">"w"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(gid_map, <span class="string">"%d %d %d"</span>, inside_id, outside_id, length);</span><br><span class="line">    fclose(gid_map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"in child program!\n"</span>);</span><br><span class="line">  <span class="keyword">cap_t</span> caps;</span><br><span class="line">  set_uid_map(getpid(), <span class="number">0</span>, <span class="number">1000</span>, <span class="number">1</span>);</span><br><span class="line">  set_gid_map(getpid(), <span class="number">0</span>, <span class="number">1000</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"eUID = %ld; eGID = %ld;"</span>, (<span class="keyword">long</span>)geteuid(), (<span class="keyword">long</span>)getegid());</span><br><span class="line">  caps = cap_get_proc();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"capabilities: %s\n"</span>, cap_to_text(caps, <span class="literal">NULL</span>));</span><br><span class="line">  execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"program begin: \n"</span>);</span><br><span class="line">  <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUSER, <span class="literal">NULL</span>);</span><br><span class="line">  waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"quit\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后即可看到user已经变成了root。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc userns.c -Wall -lcap -o userns &amp;&amp; ./userns </span><br><span class="line"><span class="function"><span class="keyword">program</span></span> begin: </span><br><span class="line"><span class="keyword">in</span> child <span class="function"><span class="keyword">program</span></span><span class="comment">!</span></span><br><span class="line">eUID = <span class="number">0</span>; eGID = <span class="number">0</span>;capabilities: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,<span class="number">37</span>+ep</span><br></pre></td></tr></table></figure>
<p>至此，你就已经完成了绑定的工作，可以看到演示全程都是在普通用户下执行的。最终实现了在user namespace中成为了root而对应到外面的是一个uid为1000的普通用户。</p>
<p>讲完了user namespace，我们再来谈谈Docker。虽然Docker目前尚未使用user namespace，但是他用到了我们在user namespace中提及的Capabilities机制。从内核2.2版本开始，Linux把原来和超级用户相关的高级权限划分成为不同的单元，称为Capability。这样管理员就可以独立对特定的Capability进行使能或禁止。Docker虽然没有使用user namespace，但是他可以禁用容器中不需要的Capability，一次在一定程度上加强容器安全性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>容器的隔离实现基本就是通过Linux内核提供的这6种namespace实现。但是容器依旧没有实现完全的环境隔离。比如: <code>SELinux</code>,<code>Cgroups</code>以及<code>/sys</code>,<code>/proc/sys</code>, <code>/dev/sd*</code>等目录下的资源依据是没有被隔离的。因此我们通常使用的<code>ps</code>， <code>top</code>命令查看到的数据依旧是宿主机的数据。因为它们的数据来源于<code>/proc</code>等目录下的文件。如果想要在可视化的角度来实现这方便的可视化隔离。可以看看之前调研的<a href="https://xigang.github.io/2018/06/30/lxcfs/" target="_blank" rel="noopener">lxcfs对docker容器隔离</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://docs.wixstatic.com/ugd/295986_d73d8d6087ed430c34c21f90b0b607fd.pdf" target="_blank" rel="noopener">http://docs.wixstatic.com/ugd/295986_d73d8d6087ed430c34c21f90b0b607fd.pdf</a><br><a href="http://ramirose.wixsite.com/ramirosen" target="_blank" rel="noopener">http://ramirose.wixsite.com/ramirosen</a><br><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link</a><br><a href="http://hustcat.github.io/namespace-implement-1/" target="_blank" rel="noopener">http://hustcat.github.io/namespace-implement-1/</a><br><a href="http://abcdxyzk.github.io/blog/2015/08/06/namespace2/" target="_blank" rel="noopener">http://abcdxyzk.github.io/blog/2015/08/06/namespace2/</a></p>
</div><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/docker/">docker</a></div><div class="post-nav"><a class="pre" href="/2018/11/05/nvidia-docker2/">Nvidia-Docker2在kubernetes上实践</a><a class="next" href="/2018/09/16/replicaset/">Kube-Controller-manager之Replicaset Controller源码解析</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'xigang',
  repo: 'https://github.com/xigang/gitment-comments',
  oauth: {
    client_id: '86d1945e3a9358946043',
    client_secret: '304f48ee3394ae5dab75d19a966506e170d850f6',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://github.com/xigang"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/云计算/">云计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储/">存储</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/etcd/" style="font-size: 15px;">etcd</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/kube-dns/" style="font-size: 15px;">kube-dns</a> <a href="/tags/microservices/" style="font-size: 15px;">microservices</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/24/kube-dns/">Kubernetes DNS 介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/nvidia-container-runtime/">深入理解 Nvidia-docker2.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/05/nvidia-docker2/">Nvidia-Docker2在kubernetes上实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/namespace-md/">浅谈 Linux Namespace</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/replicaset/">Kube-Controller-manager之Replicaset Controller源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/08/deployment/">Kube-Controller-manager之Deployment Controller源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/gpu/">GPU Container on Kubernetes</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/kong/">Api-Gateway Kong与容器服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/18/etcd-back/">Etcd集群备份及容灾恢复</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/08/cgroups/">浅谈Cgroups</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://gogap.cn/" title="gogap" target="_blank">gogap</a><ul></ul><a href="http://www.0x7c00.net/" title="31744" target="_blank">31744</a><ul></ul><a href="https://www.opsdev.cn/" title="360opsdev" target="_blank">360opsdev</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">xigang's home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>